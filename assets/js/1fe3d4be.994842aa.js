(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9576],{3905:function(n,e,t){"use strict";t.d(e,{Zo:function(){return c},kt:function(){return f}});var a=t(67294);function i(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function l(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function r(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?l(Object(t),!0).forEach((function(e){i(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function o(n,e){if(null==n)return{};var t,a,i=function(n,e){if(null==n)return{};var t,a,i={},l=Object.keys(n);for(a=0;a<l.length;a++)t=l[a],e.indexOf(t)>=0||(i[t]=n[t]);return i}(n,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(n);for(a=0;a<l.length;a++)t=l[a],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(i[t]=n[t])}return i}var u=a.createContext({}),s=function(n){var e=a.useContext(u),t=e;return n&&(t="function"==typeof n?n(e):r(r({},e),n)),t},c=function(n){var e=s(n.components);return a.createElement(u.Provider,{value:e},n.children)},p={inlineCode:"code",wrapper:function(n){var e=n.children;return a.createElement(a.Fragment,{},e)}},d=a.forwardRef((function(n,e){var t=n.components,i=n.mdxType,l=n.originalType,u=n.parentName,c=o(n,["components","mdxType","originalType","parentName"]),d=s(t),f=i,h=d["".concat(u,".").concat(f)]||d[f]||p[f]||l;return t?a.createElement(h,r(r({ref:e},c),{},{components:t})):a.createElement(h,r({ref:e},c))}));function f(n,e){var t=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var l=t.length,r=new Array(l);r[0]=d;var o={};for(var u in e)hasOwnProperty.call(e,u)&&(o[u]=e[u]);o.originalType=n,o.mdxType="string"==typeof n?n:i,r[1]=o;for(var s=2;s<l;s++)r[s]=t[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},57131:function(n,e,t){"use strict";t.r(e),t.d(e,{frontMatter:function(){return o},metadata:function(){return u},toc:function(){return s},default:function(){return p}});var a=t(22122),i=t(19756),l=(t(67294),t(3905)),r=["components"],o={title:"\u5e76\u53d1\u5bb9\u5668"},u={unversionedId:"java/hc/\u5e76\u53d1\u5bb9\u5668",id:"java/hc/\u5e76\u53d1\u5bb9\u5668",isDocsHomePage:!1,title:"\u5e76\u53d1\u5bb9\u5668",description:"ConcurrentHashMap",source:"@site/docs/java/hc/\u5e76\u53d1\u5bb9\u5668.md",sourceDirName:"java/hc",slug:"/java/hc/\u5e76\u53d1\u5bb9\u5668",permalink:"/docs.advanced.way/docs/java/hc/\u5e76\u53d1\u5bb9\u5668",editUrl:"https://github.com/Goldwood1024/docs.advanced.way/tree/master/docs/java/hc/\u5e76\u53d1\u5bb9\u5668.md",version:"current",lastUpdatedAt:1622709462,formattedLastUpdatedAt:"6/3/2021",frontMatter:{title:"\u5e76\u53d1\u5bb9\u5668"},sidebar:"java",previous:{title:"\u539f\u5b50\u7c7b",permalink:"/docs.advanced.way/docs/java/hc/\u539f\u5b50\u7c7b"},next:{title:"\u5e76\u53d1\u5de5\u5177\u7c7b",permalink:"/docs.advanced.way/docs/java/hc/\u5e76\u53d1\u5de5\u5177\u7c7b"}},s=[{value:"ConcurrentHashMap",id:"concurrenthashmap",children:[{value:"\u7ed3\u6784",id:"\u7ed3\u6784",children:[]},{value:"\u6e90\u7801",id:"\u6e90\u7801",children:[]}]},{value:"ConcurrentLinkedQueue",id:"concurrentlinkedqueue",children:[{value:"\u67b6\u6784\u56fe",id:"\u67b6\u6784\u56fe",children:[]},{value:"\u6e90\u7801",id:"\u6e90\u7801-1",children:[]}]},{value:"CopyOnWriteArrayList",id:"copyonwritearraylist",children:[{value:"\u67b6\u6784\u56fe",id:"\u67b6\u6784\u56fe-1",children:[]},{value:"\u6e90\u7801",id:"\u6e90\u7801-2",children:[]}]},{value:"\u963b\u585e\u961f\u5217",id:"\u963b\u585e\u961f\u5217",children:[{value:"\u6838\u5fc3\u7c7b",id:"\u6838\u5fc3\u7c7b",children:[]},{value:"ArrayBlockingQueue",id:"arrayblockingqueue",children:[]},{value:"LinkedBlockingQueue",id:"linkedblockingqueue",children:[]},{value:"LinkedTransferQueue",id:"linkedtransferqueue",children:[]},{value:"LinkedBlockingDeque",id:"linkedblockingdeque",children:[]},{value:"PriorityBlockingQueue",id:"priorityblockingqueue",children:[]},{value:"DelayQueue",id:"delayqueue",children:[]}]},{value:"\u53c2\u8003",id:"\u53c2\u8003",children:[]}],c={toc:s};function p(n){var e=n.components,o=(0,i.Z)(n,r);return(0,l.kt)("wrapper",(0,a.Z)({},c,o,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"concurrenthashmap"},"ConcurrentHashMap"),(0,l.kt)("h3",{id:"\u7ed3\u6784"},"\u7ed3\u6784"),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(52044).Z})),(0,l.kt)("p",null,"CAS\u65e0\u9501\u7b97\u6cd5\u4e0esynchronized\u4fdd\u8bc1\u5e76\u53d1\u5b89\u5168\uff0c\u652f\u6301\u5e76\u53d1\u6269\u5bb9\uff0c\u6570\u636e\u7ed3\u6784\u53d8\u66f4\u4e3a\u6570\u7ec4+\u94fe\u8868+\u7ea2\u9ed1\u6811\uff0c\u63d0\u9ad8\u6027\u80fd\u3002"),(0,l.kt)("h3",{id:"\u6e90\u7801"},"\u6e90\u7801"),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(32088).Z})),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public interface Map<K, V> {}\n\npublic interface ConcurrentMap<K,V> extends Map<K,V> {\n}\n\npublic abstract class AbstractMap<K,V> implements Map<K,V> {\n    public abstract Set<Entry<K,V>> entrySet();\n}\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Map")," ",(0,l.kt)("a",{parentName:"p",href:"/docs.advanced.way/docs/java/collection/Map"},"\u63a5\u53e3\u5b9a\u4e49")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'public class ConcurrentHashMap<K,V> extends AbstractMap<K,V>\n    implements ConcurrentMap<K,V>, Serializable {\n    private static final int MAXIMUM_CAPACITY = 1 << 30;\n    private static final int DEFAULT_CAPACITY = 16;\n    static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n    private static final int DEFAULT_CONCURRENCY_LEVEL = 16;\n    private static final float LOAD_FACTOR = 0.75f;\n    static final int TREEIFY_THRESHOLD = 8;\n    static final int UNTREEIFY_THRESHOLD = 6;\n    static final int MIN_TREEIFY_CAPACITY = 64;\n    private static final int MIN_TRANSFER_STRIDE = 16;\n    private static final int RESIZE_STAMP_BITS = 16;\n    private static final int MAX_RESIZERS = (1 << (32 - RESIZE_STAMP_BITS)) - 1;\n    private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;\n\n    static final int MOVED     = -1; // hash for forwarding nodes\n    static final int TREEBIN   = -2; // hash for roots of trees\n    static final int RESERVED  = -3; // hash for transient reservations\n    static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash\n    \n    static final int NCPU = Runtime.getRuntime().availableProcessors();\n\n    // \u521b\u5efa\u7a7a\u8868\n    transient volatile Node<K,V>[] table;\n\n    // \u521b\u5efa\u7a7a\u8868\uff0c\u6269\u5bb9\u65f6\u4f7f\u7528\n    private transient volatile Node<K,V>[] nextTable;\n    private transient volatile long baseCount;\n\n    // \u63a7\u5236 table \u521d\u59cb\u5316\u6216\u6269\u5bb9\n    // 0\u4ee3\u8868hash\u8868\u8fd8\u6ca1\u6709\u88ab\u521d\u59cb\u5316\n    // \u8d1f\u6570\u4ee3\u8868\u6b63\u5728\u8fdb\u884c\u521d\u59cb\u5316\u6216\u6269\u5bb9\u64cd\u4f5c\n    // -1\u4ee3\u8868\u6b63\u5728\u521d\u59cb\u5316\n    // -\uff08N+1\uff09 \u8868\u793a\u6709N\u4e2a\u7ebf\u7a0b\u6b63\u5728\u8fdb\u884c\u6269\u5bb9\u64cd\u4f5c\n    // \u6b63\u6570\u6570\u503c\u8868\u793a\u4e0b\u4e00\u6b21\u8fdb\u884c\u6269\u5bb9\u7684\u9608\u503c\uff0c\u662f\u5f53\u524dConcurrentHashMap\u5bb9\u91cf\u76840.75\u500d\uff0c\u8fd9\u4e0eloadfactor\u662f\u5bf9\u5e94\u7684\n    private transient volatile int sizeCtl;\n\n\n    // Map.Entry \u5b9e\u73b0\u7c7b\n    static final class MapEntry<K,V> implements Map.Entry<K,V> {\n        final K key; // non-null\n        V val;       // non-null\n        final ConcurrentHashMap<K,V> map;\n        MapEntry(K key, V val, ConcurrentHashMap<K,V> map) {\n            this.key = key;\n            this.val = val;\n            this.map = map;\n        }\n        public K getKey()        { return key; }\n        public V getValue()      { return val; }\n        public int hashCode()    { return key.hashCode() ^ val.hashCode(); }\n        public String toString() {\n            return Helpers.mapEntryToString(key, val);\n        }\n\n        public boolean equals(Object o) {\n            Object k, v; Map.Entry<?,?> e;\n            return ((o instanceof Map.Entry) &&\n                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&\n                    (v = e.getValue()) != null &&\n                    (k == key || k.equals(key)) &&\n                    (v == val || v.equals(val)));\n        }\n\n        public V setValue(V value) {\n            if (value == null) throw new NullPointerException();\n            V v = val;\n            val = value;\n            map.put(key, value);\n            return v;\n        }\n    }\n\n    public V put(K key, V value) {\n        return putVal(key, value, false);\n    }\n\n    final V putVal(K key, V value, boolean onlyIfAbsent) {\n        // key value \u90fd\u4e0d\u80fd\u4e3a\u7a7a\n        if (key == null || value == null) throw new NullPointerException();\n        // hash \u503c\n        int hash = spread(key.hashCode());\n        // \u7528\u4e8e\u8bb0\u5f55\u76f8\u5e94\u94fe\u8868\u7684\u957f\u5ea6\n        int binCount = 0;\n        // \u81ea\u65cb\n        for (Node<K,V>[] tab = table;;) {\n            Node<K,V> f;\n            int n, i, fh;\n            K fk;\n            V fv;\n            // \u521d\u59cb\u5316\n            if (tab == null || (n = tab.length) == 0)\n                tab = initTable();\n\n            // \u627e\u8be5 hash \u503c\u5bf9\u5e94\u7684\u6570\u7ec4\u4e0b\u6807\uff0c\u5f97\u5230\u7b2c\u4e00\u4e2a\u8282\u70b9 f\n            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n                // \u5982\u679c\u6570\u7ec4\u8be5\u4f4d\u7f6e\u4e3a\u7a7a \u7528\u4e00\u6b21 CAS \u64cd\u4f5c\u5c06\u8fd9\u4e2a\u65b0\u503c\u653e\u5165\u5176\u4e2d\n                if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value)))\n                    // cas \u6210\u529f\u9000\u51fa\n                    break;                   // no lock when adding to empty bin\n            }\n            else if ((fh = f.hash) == MOVED)\n                // \u5e2e\u52a9\u6570\u636e\u8fc1\u79fb\n                tab = helpTransfer(tab, f);\n            else if (onlyIfAbsent // check first node without acquiring lock\n                     && fh == hash\n                     && ((fk = f.key) == key || (fk != null && key.equals(fk)))\n                     && (fv = f.val) != null)\n                return fv;\n            else {\n                V oldVal = null;\n                // f \u662f\u8be5\u4f4d\u7f6e\u7684\u5934\u7ed3\u70b9\uff0c\u800c\u4e14\u4e0d\u4e3a\u7a7a\n                synchronized (f) {\n                    if (tabAt(tab, i) == f) {\n\n                        // \u5934\u7ed3\u70b9\u7684 hash \u503c\u5927\u4e8e 0\uff0c\u8bf4\u660e\u662f\u94fe\u8868\n                        if (fh >= 0) {\n                            // \u7528\u4e8e\u7d2f\u52a0\uff0c\u8bb0\u5f55\u94fe\u8868\u7684\u957f\u5ea6\n                            binCount = 1;\n                            for (Node<K,V> e = f;; ++binCount) {\n                                K ek;\n\n                                // \u5982\u679c\u53d1\u73b0\u4e86"\u76f8\u7b49"\u7684 key\uff0c\u5224\u65ad\u662f\u5426\u8981\u8fdb\u884c\u503c\u8986\u76d6\uff0c\u7136\u540e\u4e5f\u5c31\u53ef\u4ee5 break \u4e86\n                                if (e.hash == hash &&\n                                    ((ek = e.key) == key ||\n                                     (ek != null && key.equals(ek)))) {\n                                    oldVal = e.val;\n                                    if (!onlyIfAbsent)\n                                        e.val = value;\n                                    break;\n                                }\n\n                                Node<K,V> pred = e;\n                                // \u5230\u4e86\u94fe\u8868\u7684\u6700\u672b\u7aef\uff0c\u5c06\u8fd9\u4e2a\u65b0\u503c\u653e\u5230\u94fe\u8868\u7684\u6700\u540e\u9762\n                                if ((e = e.next) == null) {\n                                    pred.next = new Node<K,V>(hash, key, value);\n                                    break;\n                                }\n                            }\n                        }\n                        // \u7ea2\u9ed1\u6811\n                        else if (f instanceof TreeBin) {\n                            Node<K,V> p;\n                            binCount = 2;\n                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                           value)) != null) {\n                                oldVal = p.val;\n                                if (!onlyIfAbsent)\n                                    p.val = value;\n                            }\n                        }\n                        else if (f instanceof ReservationNode)\n                            throw new IllegalStateException("Recursive update");\n                    }\n                }\n\n                // binCount != 0 \u8bf4\u660e\u4e0a\u9762\u5728\u505a\u94fe\u8868\u64cd\u4f5c\n                if (binCount != 0) {\n                    // \u5224\u65ad\u662f\u5426\u8981\u5c06\u94fe\u8868\u8f6c\u6362\u4e3a\u7ea2\u9ed1\u6811\n                    if (binCount >= TREEIFY_THRESHOLD)\n                        treeifyBin(tab, i);\n                    if (oldVal != null)\n                        return oldVal;\n                    break;\n                }\n            }\n        }\n        addCount(1L, binCount);\n        return null;\n    }\n\n    static final int spread(int h) {\n        return (h ^ (h >>> 16)) & HASH_BITS;\n    }\n\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u5408\u9002\u5927\u5c0f\u7684\u6570\u7ec4\uff0c\u7136\u540e\u4f1a\u8bbe\u7f6e sizeCtl\n    private final Node<K,V>[] initTable() {\n        Node<K,V>[] tab; int sc;\n        while ((tab = table) == null || tab.length == 0) {\n            // \u521d\u59cb\u5316\u7684\u64cd\u4f5c\u88ab\u5176\u4ed6\u7ebf\u7a0b\u6267\u884c\n            if ((sc = sizeCtl) < 0)\n                Thread.yield(); // lost initialization race; just spin\n\n            // CAS \u4e00\u4e0b\uff0c\u5c06 sizeCtl \u8bbe\u7f6e\u4e3a -1\uff0c\u4ee3\u8868\u62a2\u5230\u4e86\u9501\n            else if (U.compareAndSetInt(this, SIZECTL, sc, -1)) {\n                try {\n                    if ((tab = table) == null || tab.length == 0) {\n                        // \u9ed8\u8ba4\u5bb9\u91cf\u5927\u5c0f\n                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;\n                        // \u521d\u59cb\u5316 Node \u6570\u7ec4\n                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                        table = tab = nt;\n                        sc = n - (n >>> 2);\n                    }\n                } finally {\n                    // 12\n                    sizeCtl = sc;\n                }\n                break;\n            }\n        }\n        return tab;\n    }\n\n     private final void treeifyBin(Node<K,V>[] tab, int index) {\n        Node<K,V> b; int n;\n        if (tab != null) {\n            // \u6570\u7ec4\u5c0f\u4e8e 64\uff0c\u6269\u5bb9\n            if ((n = tab.length) < MIN_TREEIFY_CAPACITY)\n                // \u52a0\u500d\n                tryPresize(n << 1);\n            // \u6811\u5316\n            else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {\n                synchronized (b) {\n                    if (tabAt(tab, index) == b) {\n                        TreeNode<K,V> hd = null, tl = null;\n                        for (Node<K,V> e = b; e != null; e = e.next) {\n                            TreeNode<K,V> p =\n                                new TreeNode<K,V>(e.hash, e.key, e.val,\n                                                  null, null);\n                            if ((p.prev = tl) == null)\n                                hd = p;\n                            else\n                                tl.next = p;\n                            tl = p;\n                        }\n                        setTabAt(tab, index, new TreeBin<K,V>(hd));\n                    }\n                }\n            }\n        }\n    }\n\n    // ABASE \u8868\u793a table\u4e2d\u9996\u4e2a\u5143\u7d20\u7684\u5185\u5b58\u504f\u79fb\u5730\u5740\uff0c\u6240\u4ee5(long)i << ASHIFT) + ABASE \u5f97\u5230 table[i] \u7684\u5185\u5b58\u504f\u79fb\u5730\n    static final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i) {\n        return (Node<K,V>)U.getObjectAcquire(tab, ((long)i << ASHIFT) + ABASE);\n    }\n\n    static final <K,V> boolean casTabAt(Node<K,V>[] tab, int i,\n                                        Node<K,V> c, Node<K,V> v) {\n        return U.compareAndSetObject(tab, ((long)i << ASHIFT) + ABASE, c, v);\n    }\n\n    static final <K,V> void setTabAt(Node<K,V>[] tab, int i, Node<K,V> v) {\n        U.putObjectVolatile(tab, ((long)i << ASHIFT) + ABASE, v);\n    }\n\n    // 1. \u68c0\u6d4b\u662f\u5426\u9700\u8981\u6269\u5bb9 2. \u66f4\u65b0\u7ed3\u70b9\u6570\u91cf\n    private final void addCount(long x, int check) {\n        CounterCell[] cs; long b, s;\n        if ((cs = counterCells) != null ||\n            !U.compareAndSetLong(this, BASECOUNT, b = baseCount, s = b + x)) {\n            CounterCell c; long v; int m;\n            boolean uncontended = true;\n            if (cs == null || (m = cs.length - 1) < 0 ||\n                (c = cs[ThreadLocalRandom.getProbe() & m]) == null ||\n                !(uncontended =\n                  U.compareAndSetLong(c, CELLVALUE, v = c.value, v + x))) {\n                fullAddCount(x, uncontended);\n                return;\n            }\n            if (check <= 1)\n                return;\n            s = sumCount();\n        }\n        if (check >= 0) {\n            Node<K,V>[] tab, nt; int n, sc;\n            while (s >= (long)(sc = sizeCtl) && (tab = table) != null &&\n                   (n = tab.length) < MAXIMUM_CAPACITY) {\n                int rs = resizeStamp(n);\n                if (sc < 0) {\n                    if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n                        sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||\n                        transferIndex <= 0)\n                        break;\n                    if (U.compareAndSetInt(this, SIZECTL, sc, sc + 1))\n                        transfer(tab, nt);\n                }\n                else if (U.compareAndSetInt(this, SIZECTL, sc,\n                                             (rs << RESIZE_STAMP_SHIFT) + 2))\n                    transfer(tab, null);\n                s = sumCount();\n            }\n        }\n    }\n\n    // put\uff0cremove\u7b49\u60c5\u51b5\u4e0b\u9047\u5230\u6269\u5bb9\uff0c\u5982\u679c\u5f53\u524d\u5f53\u524d\u7ebf\u7a0b\u9047\u5230Forwarding\u7ed3\u70b9\uff0c\n    // \u53d1\u73b0\u6b63\u5728\u6269\u5bb9\uff0c\u5c31\u4f1a\u5e2e\u52a9\u6269\u5bb9\uff1b\u5982\u679c\u6ca1\u6709\u53d1\u73b0\u6269\u5bb9\uff0c\u90a3\u4e48\u4ecd\u7136\u53ef\u4ee5\u7ee7\u7eed\u64cd\u4f5c\n    final Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) {\n        Node<K,V>[] nextTab; int sc;\n        if (tab != null && (f instanceof ForwardingNode) &&\n            (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) {\n            int rs = resizeStamp(tab.length);\n            while (nextTab == nextTable && table == tab &&\n                   (sc = sizeCtl) < 0) {\n                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n                    sc == rs + MAX_RESIZERS || transferIndex <= 0)\n                    break;\n\n                // \u901a\u8fc7CAS\u64cd\u4f5c\u83b7\u53d6\u6269\u5bb9\u540d\u989d\n                if (U.compareAndSetInt(this, SIZECTL, sc, sc + 1)) {\n                    // \u6570\u636e\u8fc1\u79fb\n                    transfer(tab, nextTab);\n                    break;\n                }\n            }\n            return nextTab;\n        }\n        return table;\n    }\n\n    private final void tryPresize(int size) {\n        // c\uff1asize \u7684 1.5 \u500d\uff0c\u518d\u52a0 1\uff0c\u518d\u5f80\u4e0a\u53d6\u6700\u8fd1\u7684 2 \u7684 n \u6b21\u65b9\u3002\n        int c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size >>> 1) + 1);\n        int sc;\n        while ((sc = sizeCtl) >= 0) {\n            Node<K,V>[] tab = table; int n;\n            // \u521d\u59cb\u5316\u6570\u7ec4\n            if (tab == null || (n = tab.length) == 0) {\n                n = (sc > c) ? sc : c;\n                if (U.compareAndSetInt(this, SIZECTL, sc, -1)) {\n                    try {\n                        if (table == tab) {\n                            @SuppressWarnings("unchecked")\n                            Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                            table = nt;\n                            sc = n - (n >>> 2);\n                        }\n                    } finally {\n                        sizeCtl = sc;\n                    }\n                }\n            }\n            else if (c <= sc || n >= MAXIMUM_CAPACITY)\n                break;\n            else if (tab == table) {\n                int rs = resizeStamp(n);\n                if (U.compareAndSetInt(this, SIZECTL, sc, (rs << RESIZE_STAMP_SHIFT) + 2))\n                    transfer(tab, null);\n            }\n        }\n    }\n\n    private static final int tableSizeFor(int c) {\n        int n = -1 >>> Integer.numberOfLeadingZeros(c - 1);\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n\n    private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {\n        int n = tab.length, stride;\n        // NCPU = cpu \u6838\u5fc3\u6570\n        // \u8ba1\u7b97\u6bcf\u6761\u7ebf\u7a0b\u5904\u7406\u7684\u6876\u4e2a\u6570\uff0c\u6bcf\u6761\u7ebf\u7a0b\u5904\u7406\u7684\u6876\u6570\u91cf\u4e00\u6837\uff1b\u6bcf\u4e2a\u7ebf\u7a0b\u5904\u7406\u6876\u7684\u6700\u5c0f\u6570\u76ee\uff0c\u53ef\u4ee5\u770b\u51fa\u6838\u6570\u8d8a\u9ad8\u6b65\u957f\u8d8a\u5c0f\uff0c\u6700\u5c0f16\u4e2a\uff0c\u3002\n        if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)\n            stride = MIN_TRANSFER_STRIDE; // subdivide range\n\n        // \u8fd8\u672a\u6307\u5b9a\u4e0b\u4e00\u4e2a\u8868\uff0c\u5219\u65b0\u5efa\u76ee\u6807\u8868\u7684\u5927\u5c0f\uff1b\n        if (nextTab == null) {            // initiating\n            try {\n                @SuppressWarnings("unchecked")\n                Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];\n                nextTab = nt;\n            } catch (Throwable ex) {      // try to cope with OOME\n                sizeCtl = Integer.MAX_VALUE;\n                return;\n            }\n            nextTable = nextTab;\n            // \u6269\u5bb9\u603b\u8fdb\u5ea6\uff0c>=transferIndex\u7684\u6876\u90fd\u5df2\u5206\u914d\u51fa\u53bb\n            transferIndex = n;\n        }\n        int nextn = nextTab.length;\n\n        // \u6807\u660e\u6b64\u8282\u70b9\u6b63\u5728\u8fdb\u884c\u8fc1\u79fb\uff0c\u6269\u5bb9\u671f\u95f4\u7684\u5143\u7d20\u67e5\u627e\u8981\u8c03\u7528\u5176find()\u65b9\u6cd5\u5728nextTable\u4e2d\u67e5\u627e\u5143\u7d20\u3002\n        ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);\n        \n        // \u5f53\u524d\u7ebf\u7a0b\u662f\u5426\u9700\u8981\u7ee7\u7eed\u5bfb\u627e\u4e0b\u4e00\u4e2a\u53ef\u5904\u7406\u7684\u8282\u70b9\n        boolean advance = true;\n\n        // \u6240\u6709\u6876\u662f\u5426\u90fd\u5df2\u8fc1\u79fb\u5b8c\u6210\n        boolean finishing = false; // to ensure sweep before committing nextTab\n        for (int i = 0, bound = 0;;) {\n            Node<K,V> f; int fh;\n            while (advance) {\n                int nextIndex, nextBound;\n\n                // \u5904\u7406\u4e00\u4e2a\u6876\u5c31i\u51cf1\n                if (--i >= bound || finishing)\n                    advance = false;\n\n                // \u8fc1\u79fb\u603b\u8fdb\u5ea6<=0\uff0c\u8868\u793a\u6240\u6709\u6876\u90fd\u5df2\u8fc1\u79fb\u5b8c\u6210\uff0ci\u7f6e-1\uff0cadvance\u4e3afalse\uff0c\u540e\u7eed\u6839\u636e\u8fd9\u4e2a\u9000\u51fa\u6269\u5bb9\n                else if ((nextIndex = transferIndex) <= 0) {\n                    i = -1;\n                    advance = false;\n                }\n\n                // \u9996\u6b21\u8fdb\u5165for\u5faa\u73af\u4f1a\u8fdb\u5165\u8be5\u51fd\u6570\uff0c\u8bbe\u7f6e\u4efb\u52a1\u533a\u95f4\n                else if (U.compareAndSetInt\n                         (this, TRANSFERINDEX, nextIndex,\n                          nextBound = (nextIndex > stride ?\n                                       nextIndex - stride : 0))) {// transferIndex\u51cf\u53bb\u5df2\u5206\u914d\u51fa\u53bb\u7684\u6876\u3002\n\n                    // \u786e\u5b9a\u5f53\u524d\u7ebf\u7a0b\u6bcf\u6b21\u5206\u914d\u7684\u5f85\u8fc1\u79fb\u6876\u7684\u8303\u56f4\u4e3a[bound, nextIndex)\n                    bound = nextBound;\n                    i = nextIndex - 1;\n                    advance = false;\n                }\n            }\n\n            // \u6269\u5bb9\u7ed3\u675f\uff0cnextTable \u53ea\u6709\u6269\u5bb9\u65f6\u624d\u4e0d\u4e3anull\uff1b\u5c06table\u6307\u5411\u65b0\u8868\uff0c\u91cd\u65b0\u8bbe\u7f6esizeCtl\n            if (i < 0 || i >= n || i + n >= nextn) {\n                int sc;\n                if (finishing) {\n                    nextTable = null;\n                    table = nextTab;\n                    sizeCtl = (n << 1) - (n >>> 1);\n                    return;\n                }\n\n                // \u6bcf\u5f53\u4e00\u6761\u7ebf\u7a0b\u6269\u5bb9\u7ed3\u675f\u5c31\u4f1a\u66f4\u65b0\u4e00\u6b21 sizeCtl \u7684\u503c\uff0c\u8fdb\u884c\u51cf1\u64cd\u4f5c,\u6269\u5bb9\u4e2d\uff0csizeCtl\u8868\u793a\u6709\u591a\u5c11\u4e2a\u7ebf\u7a0b\n                if (U.compareAndSetInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {\n                    // \u8fd8\u8bb0\u5f97addCount()\u5904\u7ed9sizeCtl\u8d4b\u7684\u521d\u503c\u5417\uff1f\u76f8\u7b49\u65f6\u8bf4\u660e\u6ca1\u6709\u7ebf\u7a0b\u5728\u53c2\u4e0e\u6269\u5bb9\u4e86\uff0c\n                    // \u7f6efinishing=advance=true\uff0c\u4e3a\u4fdd\u9669\u8ba9i=n\u518d\u68c0\u67e5\u4e00\u6b21\u3002\n                    if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)\n                        return;\n                    // \u5c06i\u8bbe\u7f6e\u4e3an\uff0c\u518d\u91cd\u65b0\u68c0\u67e5\u662f\u4e0d\u662f\u6240\u6709\u7684\u7ed3\u70b9\u90fd\u5b8c\u6210\u8f6c\u79fb\u4e86\n                    finishing = advance = true;\n                    i = n; // recheck before commit\n                }\n            }\n            // \u7a7a\u6876\uff0c\u653efwd\u6807\u8bc6\u6269\u5bb9\u72b6\u6001\n            else if ((f = tabAt(tab, i)) == null)\n                // \u5982\u679ci\u5904\u662fForwardingNode\u8868\u793a\u7b2ci\u4e2a\u6876\u5df2\u7ecf\u6709\u7ebf\u7a0b\u5728\u8d1f\u8d23\u8fc1\u79fb\u4e86\u3002\n                advance = casTabAt(tab, i, null, fwd);\n            // \u5df2\u7ecf\u653e\u7f6e\u4e86fwd\uff0c\u6269\u5bb9\u4e86\uff0c\u68c0\u67e5\u4e0b\u4e00\u4e2a\n            else if ((fh = f.hash) == MOVED)\n                advance = true; // already processed\n            else {\n                // \u6876\u5185\u5143\u7d20\u8fc1\u79fb\u9700\u8981\u52a0\u9501\n                synchronized (f) {\n                    if (tabAt(tab, i) == f) {\n                        Node<K,V> ln, hn;\n                        if (fh >= 0) {\n                            // \u7531\u4e8en\u662f2\u7684\u5e42\u6b21\u65b9\uff08\u6240\u6709\u4e8c\u8fdb\u5236\u4f4d\u4e2d\u53ea\u6709\u4e00\u4e2a1)\uff0c\u5982n=16(0001 0000)\uff0c\u7b2c4\u4f4d\u4e3a1\uff0c\u90a3\u4e48hash&n\u540e\u7684\u503c\u7b2c4\u4f4d\u53ea\u80fd\u4e3a0\u62161\u3002\n                            // \u6240\u4ee5\u53ef\u4ee5\u6839\u636ehash&n\u7684\u7ed3\u679c\u5c06\u6240\u6709\u7ed3\u70b9\u5206\u4e3a\u4e24\u90e8\u5206\u3002\n                            int runBit = fh & n;\n                            Node<K,V> lastRun = f;\n                            for (Node<K,V> p = f.next; p != null; p = p.next) {\n                                int b = p.hash & n;\n                                if (b != runBit) {\n                                    runBit = b;\n                                    lastRun = p;\n                                }\n                            }\n                            if (runBit == 0) {\n                                ln = lastRun;\n                                hn = null;\n                            }\n                            else {\n                                hn = lastRun;\n                                ln = null;\n                            }\n\n                            // \u627e\u51fa\u6700\u540e\u4e00\u6bb5\u5b8c\u6574\u7684 fh&n \u4e0d\u53d8\u7684\u94fe\u8868\uff0c\u8fd9\u6837\u6700\u540e\u8fd9\u4e00\u6bb5\u94fe\u8868\u5c31\u4e0d\u7528\u91cd\u65b0\u521b\u5efa\u65b0\u7ed3\u70b9\u4e86\n                            for (Node<K,V> p = f; p != lastRun; p = p.next) {\n                                int ph = p.hash; K pk = p.key; V pv = p.val;\n                                if ((ph & n) == 0)\n                                    ln = new Node<K,V>(ph, pk, pv, ln);\n                                else\n                                    hn = new Node<K,V>(ph, pk, pv, hn);\n                            }\n                            // \u4f4e\u4f4d\u94fe\u8868\u653e\u5728i\u5904\n                            setTabAt(nextTab, i, ln);\n                            // \u9ad8\u4f4d\u94fe\u8868\u653e\u5728i+n\u5904\n                            setTabAt(nextTab, i + n, hn);\n                            setTabAt(tab, i, fwd);\n                            advance = true;\n                        }\n                        else if (f instanceof TreeBin) {\n                            TreeBin<K,V> t = (TreeBin<K,V>)f;\n                            TreeNode<K,V> lo = null, loTail = null;\n                            TreeNode<K,V> hi = null, hiTail = null;\n                            int lc = 0, hc = 0;\n                            for (Node<K,V> e = t.first; e != null; e = e.next) {\n                                int h = e.hash;\n                                TreeNode<K,V> p = new TreeNode<K,V>\n                                    (h, e.key, e.val, null, null);\n                                if ((h & n) == 0) {\n                                    if ((p.prev = loTail) == null)\n                                        lo = p;\n                                    else\n                                        loTail.next = p;\n                                    loTail = p;\n                                    ++lc;\n                                }\n                                else {\n                                    if ((p.prev = hiTail) == null)\n                                        hi = p;\n                                    else\n                                        hiTail.next = p;\n                                    hiTail = p;\n                                    ++hc;\n                                }\n                            }\n                            ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) :\n                                (hc != 0) ? new TreeBin<K,V>(lo) : t;\n                            hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) :\n                                (lc != 0) ? new TreeBin<K,V>(hi) : t;\n                            setTabAt(nextTab, i, ln);\n                            setTabAt(nextTab, i + n, hn);\n                            setTabAt(tab, i, fwd);\n                            advance = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    static final class ForwardingNode<K,V> extends Node<K,V> {\n        final Node<K,V>[] nextTable;\n        ForwardingNode(Node<K,V>[] tab) {\n            super(MOVED, null, null);\n            this.nextTable = tab;\n        }\n\n        Node<K,V> find(int h, Object k) {\n            // loop to avoid arbitrarily deep recursion on forwarding nodes\n            outer: for (Node<K,V>[] tab = nextTable;;) {\n                Node<K,V> e; int n;\n                if (k == null || tab == null || (n = tab.length) == 0 ||\n                    (e = tabAt(tab, (n - 1) & h)) == null)\n                    return null;\n                for (;;) {\n                    int eh; K ek;\n                    if ((eh = e.hash) == h &&\n                        ((ek = e.key) == k || (ek != null && k.equals(ek))))\n                        return e;\n                    if (eh < 0) {\n                        if (e instanceof ForwardingNode) {\n                            tab = ((ForwardingNode<K,V>)e).nextTable;\n                            continue outer;\n                        }\n                        else\n                            return e.find(h, k);\n                    }\n                    if ((e = e.next) == null)\n                        return null;\n                }\n            }\n        }\n    }\n\n    public V get(Object key) {\n        Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;\n        // \u8ba1\u7b97hash\u503c\n        int h = spread(key.hashCode());\n        if ((tab = table) != null && (n = tab.length) > 0 && (e = tabAt(tab, (n - 1) & h)) != null) {\n\n            // \u5224\u65ad\u5934\u7ed3\u70b9\u662f\u5426\u5c31\u662f\u6211\u4eec\u9700\u8981\u7684\u8282\u70b9\n            if ((eh = e.hash) == h) {\n                if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                    return e.val;\n            }\n            // \u5982\u679c\u5934\u7ed3\u70b9\u7684 hash \u5c0f\u4e8e 0\uff0c\u8bf4\u660e \u6b63\u5728\u6269\u5bb9\u6216\u8005\u8be5\u4f4d\u7f6e\u662f\u7ea2\u9ed1\u6811\n            else if (eh < 0)\n                return (p = e.find(h, key)) != null ? p.val : null;\n\n            // \u904d\u5386\u94fe\u8868\n            while ((e = e.next) != null) {\n                if (e.hash == h &&\n                    ((ek = e.key) == key || (ek != null && key.equals(ek))))\n                    return e.val;\n            }\n        }\n        return null;\n    }\n}\n')),(0,l.kt)("p",null,"put \u65b9\u6cd5\u6d41\u7a0b:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"\u6839\u636e key \u8ba1\u7b97\u51fa hashcode \u3002"),(0,l.kt)("li",{parentName:"ul"},"\u5224\u65ad\u8868\u662f\u5426\u9700\u8981\u8fdb\u884c\u521d\u59cb\u5316\u3002"),(0,l.kt)("li",{parentName:"ul"},"\u5b9a\u4f4d\u51fa\u7684\u76ee\u6807\u6876\uff0c\u5982\u679c\u4e3a\u7a7a\u8868\u793a\u5f53\u524d\u4f4d\u7f6e\u53ef\u4ee5\u5199\u5165\u6570\u636e\uff0c\u5229\u7528 CAS \u5c1d\u8bd5\u5199\u5165\uff0c\u5931\u8d25\u5219\u81ea\u65cb\u3002"),(0,l.kt)("li",{parentName:"ul"},"\u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u7684 hashcode == MOVED == -1,\u5219\u5e2e\u52a9\u6269\u5bb9\uff0c\u6269\u5bb9\u5b8c\u6210\u540e\u624d\u8fdb\u884c\u63d2\u5165\u3002"),(0,l.kt)("li",{parentName:"ul"},"\u5982\u679c\u6ca1\u6709\u7279\u6b8a\u60c5\u51b5\uff0c\u5219\u5229\u7528 synchronized \u9501\u5199\u5165\u6570\u636e\u3002"),(0,l.kt)("li",{parentName:"ul"},"\u5982\u679c\u6570\u91cf\u5927\u4e8e TREEIFY_THRESHOLD\uff088\uff09 \u5219\u8981\u8f6c\u6362\u4e3a\u7ea2\u9ed1\u6811\u3002"),(0,l.kt)("li",{parentName:"ul"},"\u63d2\u5165\u5b8c\u6210\uff0c\u6211\u4eec\u5224\u65ad\u4e00\u4e0b\u662f\u4e0d\u662f\u8981\u6269\u5bb9\uff0c\u5e76\u8bb0\u5f55\u4e00\u4e0bNode\u6570\u91cf;\u65b9\u4fbf\u7edf\u8ba1")),(0,l.kt)("h2",{id:"concurrentlinkedqueue"},"ConcurrentLinkedQueue"),(0,l.kt)("p",null,"\u4e00\u4e2a\u57fa\u4e8e\u94fe\u63a5\u8282\u70b9\u7684\u65e0\u754c\u7ebf\u7a0b\u5b89\u5168\u961f\u5217\uff0c\u5b83\u91c7\u7528\u5148\u8fdb\u5148\u51fa\u7684\u89c4\u5219\u5bf9\u8282\u70b9\u8fdb\u884c\u6392\u5e8f\uff0c\u5f53\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u5143\u7d20\u7684\u65f6\u5019\uff0c\u5b83\u4f1a\u6dfb\u52a0\u5230\u961f\u5217\u7684\u5c3e\u90e8\uff0c\u5f53\u6211\u4eec\u83b7\u53d6\u4e00\u4e2a\u5143\u7d20\u65f6\uff0c\u5b83\u4f1a\u8fd4\u56de\u961f\u5217\u5934\u90e8\u7684\u5143\u7d20"),(0,l.kt)("h3",{id:"\u67b6\u6784\u56fe"},"\u67b6\u6784\u56fe"),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(6242).Z})),(0,l.kt)("h3",{id:"\u6e90\u7801-1"},"\u6e90\u7801"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'public class ConcurrentLinkedQueue<E> extends AbstractQueue<E>\n        implements Queue<E>, java.io.Serializable {\n    transient volatile Node<E> head;\n    private transient volatile Node<E> tail;\n\n    private static final VarHandle HEAD;\n    private static final VarHandle TAIL;\n    static final VarHandle ITEM;\n    static final VarHandle NEXT;\n\n    public ConcurrentLinkedQueue() {\n        head = tail = new Node<E>();\n    }\n\n    static final class Node<E> {\n        volatile E item;\n        volatile Node<E> next;\n\n        /**\n         * Constructs a node holding item.  Uses relaxed write because\n         * item can only be seen after piggy-backing publication via CAS.\n         */\n        Node(E item) {\n            ITEM.set(this, item);\n        }\n\n        /** Constructs a dead dummy node. */\n        Node() {}\n\n        void appendRelaxed(Node<E> next) {\n            // assert next != null;\n            // assert this.next == null;\n            NEXT.set(this, next);\n        }\n\n        boolean casItem(E cmp, E val) {\n            // assert item == cmp || item == null;\n            // assert cmp != null;\n            // assert val == null;\n            return ITEM.compareAndSet(this, cmp, val);\n        }\n    }\n\n    public boolean add(E e) {\n        return offer(e);\n    }\n\n    // \u5165\u961f\n    public boolean offer(E e) {\n        // \u521b\u5efa\u8282\u70b9\n        final Node<E> newNode = new Node<E>(Objects.requireNonNull(e));\n\n        // \u6839\u636etail\u8282\u70b9\u5b9a\u4f4d\u51fa\u5c3e\u8282\u70b9\n        for (Node<E> t = tail, p = t;;) {\n            Node<E> q = p.next;\n            // \u653e\u5165\u5c3e\u90e8\n            if (q == null) {\n                // p is last node\n                // \u5c06\u65b0\u8282\u70b9\u7f6e\u4e3a\u5c3e\u8282\u70b9\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\n                if (NEXT.compareAndSet(p, null, newNode)) {\n                    // Successful CAS is the linearization point\n                    // for e to become an element of this queue,\n                    // and for newNode to become "live".\n                    if (p != t) // hop two nodes at a time; failure is OK\n                        TAIL.weakCompareAndSet(this, t, newNode);\n                    return true;\n                }\n                // Lost CAS race to another thread; re-read next\n            }\n            else if (p == q)\n                // We have fallen off list.  If tail is unchanged, it\n                // will also be off-list, in which case we need to\n                // jump to head, from which all live nodes are always\n                // reachable.  Else the new tail is a better bet.\n                p = (t != (t = tail)) ? t : head;\n            else\n                // \u5bfb\u627e\u5c3e\u8282\u70b9\n                // Check for tail updates after two hops.\n                p = (p != t && t != (t = tail)) ? t : q;\n        }\n    }\n\n    // \u51fa\u961f\n    public E poll() {\n        restartFromHead: for (;;) {\n            for (Node<E> h = head, p = h, q;; p = q) {\n                final E item;\n                if ((item = p.item) != null && p.casItem(item, null)) {\n                    // Successful CAS is the linearization point\n                    // for item to be removed from this queue.\n                    if (p != h) // hop two nodes at a time\n                        updateHead(h, ((q = p.next) != null) ? q : p);\n                    return item;\n                }\n                else if ((q = p.next) == null) {\n                    updateHead(h, p);\n                    return null;\n                }\n                else if (p == q)\n                    continue restartFromHead;\n            }\n        }\n    }\n        \n}\n')),(0,l.kt)("h2",{id:"copyonwritearraylist"},"CopyOnWriteArrayList"),(0,l.kt)("p",null,"Copy-On-Write\u7b80\u79f0COW\uff0c\u662f\u4e00\u79cd\u7528\u4e8e\u7a0b\u5e8f\u8bbe\u8ba1\u4e2d\u7684\u4f18\u5316\u7b56\u7565\u3002\n\u5176\u57fa\u672c\u601d\u8def\u662f\uff0c\u4ece\u4e00\u5f00\u59cb\u5927\u5bb6\u90fd\u5728\u5171\u4eab\u540c\u4e00\u4e2a\u5185\u5bb9\uff0c\u5f53\u67d0\u4e2a\u4eba\u60f3\u8981\u4fee\u6539\u8fd9\u4e2a\u5185\u5bb9\u7684\u65f6\u5019\uff0c\u624d\u4f1a\u771f\u6b63\u628a\u5185\u5bb9Copy\u51fa\u53bb\u5f62\u6210\u4e00\u4e2a\u65b0\u7684\u5185\u5bb9\u7136\u540e\u518d\u6539\uff0c\u8fd9\u662f\u4e00\u79cd\u5ef6\u65f6\u61d2\u60f0\u7b56\u7565"),(0,l.kt)("p",null,"CopyOnWrite\u5e76\u53d1\u5bb9\u5668\u7528\u4e8e\u8bfb\u591a\u5199\u5c11\u7684\u5e76\u53d1\u573a\u666f \u6bd4\u5982: \u767d\u540d\u5355\uff0c\u9ed1\u540d\u5355\uff0c\u5546\u54c1\u7c7b\u76ee\u7684\u8bbf\u95ee\u548c\u66f4\u65b0\u573a\u666f"),(0,l.kt)("p",null,"\u7f3a\u70b9:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u5185\u5b58\u5360\u7528\u95ee\u9898 \u56e0\u4e3aCopyOnWrite\u7684\u5199\u65f6\u590d\u5236\u673a\u5236\uff0c\u6240\u4ee5\u5728\u8fdb\u884c\u5199\u64cd\u4f5c\u7684\u65f6\u5019\uff0c\u5185\u5b58\u91cc\u4f1a\u540c\u65f6\u9a7b\u624e\u4e24\u4e2a\u5bf9\u8c61\u7684\u5185\u5b58\uff0c\u65e7\u7684\u5bf9\u8c61\u548c\u65b0\u5199\u5165\u7684\u5bf9\u8c61")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u6570\u636e\u4e00\u81f4\u6027\u95ee\u9898 \u53ea\u80fd\u4fdd\u8bc1\u6570\u636e\u7684\u6700\u7ec8\u4e00\u81f4\u6027\uff0c\u4e0d\u80fd\u4fdd\u8bc1\u6570\u636e\u7684\u5b9e\u65f6\u4e00\u81f4\u6027"))),(0,l.kt)("h3",{id:"\u67b6\u6784\u56fe-1"},"\u67b6\u6784\u56fe"),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(49659).Z})),(0,l.kt)("h3",{id:"\u6e90\u7801-2"},"\u6e90\u7801"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public class CopyOnWriteArrayList<E>\n    implements List<E>, RandomAccess, Cloneable, java.io.Serializable {\n\n    final transient Object lock = new Object();\n\n    // \u5bb9\u5668\n    private transient volatile Object[] array;\n\n    final Object[] getArray() {\n        return array;\n    }\n\n    final void setArray(Object[] a) {\n        array = a;\n    }\n\n    // \u9ed8\u8ba4\u6784\u9020\u5668\n    public CopyOnWriteArrayList() {\n        setArray(new Object[0]);\n    }\n\n    // \u83b7\u53d6\u5143\u7d20\n    public E get(int index) {\n        return elementAt(getArray(), index);\n    }\n\n    static <E> E elementAt(Object[] a, int index) {\n        // \u8bfb\u7684\u65f6\u5019\u4e0d\u9700\u8981\u52a0\u9501\uff0c\u5982\u679c\u8bfb\u7684\u65f6\u5019\u6709\u591a\u4e2a\u7ebf\u7a0b\u6b63\u5728\u5411CopyOnWriteArrayList\u6dfb\u52a0\u6570\u636e\uff0c\u8bfb\u8fd8\u662f\u4f1a\u8bfb\u5230\u65e7\u7684\u6570\u636e\n        return (E) a[index];\n    }\n\n    public boolean add(E e) {\n        // \u52a0\u9501\n        synchronized (lock) {\n            // \u83b7\u53d6\u5bb9\u5668\n            Object[] es = getArray();\n            int len = es.length;\n            // \u590d\u5236\u51fa\u65b0\u6570\u7ec4\n            es = Arrays.copyOf(es, len + 1);\n            // \u628a\u65b0\u5143\u7d20\u6dfb\u52a0\u5230\u65b0\u6570\u7ec4\u91cc\n            es[len] = e;\n            // \u628a\u539f\u6570\u7ec4\u5f15\u7528\u6307\u5411\u65b0\u6570\u7ec4\n            setArray(es);\n            return true;\n        }\n    }\n}\n")),(0,l.kt)("h2",{id:"\u963b\u585e\u961f\u5217"},"\u963b\u585e\u961f\u5217"),(0,l.kt)("p",null,"\u652f\u6301\u4e24\u4e2a\u9644\u52a0\u64cd\u4f5c\u7684\u961f\u5217"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"\u652f\u6301\u963b\u585e\u7684\u63d2\u5165\u65b9\u6cd5")),(0,l.kt)("p",null,"\u961f\u5217\u6ee1\u65f6\uff0c\u961f\u5217\u963b\u585e\u63d2\u5165\u5143\u7d20\u7684\u7ebf\u7a0b"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"\u652f\u6301\u963b\u585e\u7684\u79fb\u9664\u65b9\u6cd5")),(0,l.kt)("p",null,"\u961f\u5217\u4e3a\u7a7a\u65f6\uff0c\u83b7\u53d6\u5143\u7d20\u7684\u7ebf\u7a0b\u4f1a\u7b49\u5f85\u961f\u5217\u4e3a\u975e\u7a7a"),(0,l.kt)("h3",{id:"\u6838\u5fc3\u7c7b"},"\u6838\u5fc3\u7c7b"),(0,l.kt)("h4",{id:"blockingqueueclass"},"BlockingQueue.class"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public interface BlockingQueue<E> extends Queue<E>{\n\n}\n")),(0,l.kt)("h4",{id:"abstractqueueclass"},"AbstractQueue.class"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public abstract class AbstractQueue<E>\n    extends AbstractCollection<E>\n    implements Queue<E> {\n}\n")),(0,l.kt)("h3",{id:"arrayblockingqueue"},"ArrayBlockingQueue"),(0,l.kt)("p",null,"\u4e00\u4e2a\u6570\u7ec4\u5b9e\u73b0\u7684\u6709\u754c\u961f\u5217\uff08FIFO\uff09"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'public class ArrayBlockingQueue<E> extends AbstractQueue<E>\n        implements BlockingQueue<E>, java.io.Serializable {\n    \n    // \u5bb9\u5668\n    final Object[] items;\n\n    // \u5143\u7d20\u4e2a\u6570\n    int count;\n\n    final ReentrantLock lock;\n    private final Condition notEmpty;\n    private final Condition notFull;\n\n    // \u9ed8\u8ba4\u975e\u516c\u5e73\n    public ArrayBlockingQueue(int capacity) {\n        this(capacity, false);\n    }\n\n    // \u53ef\u4ee5\u6307\u5b9a\u8bbf\u95ee\u6a21\u5f0f\uff08\u516c\u5e73\u6216\u975e\u516c\u5e73\uff09\n    public ArrayBlockingQueue(int capacity, boolean fair) {\n        if (capacity <= 0)\n            throw new IllegalArgumentException();\n        this.items = new Object[capacity];\n        lock = new ReentrantLock(fair);\n        notEmpty = lock.newCondition();\n        notFull =  lock.newCondition();\n    }\n\n    // \u63d2\u5165\u5143\u7d20\n    public boolean offer(E e) {\n        Objects.requireNonNull(e);\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            if (count == items.length)\n                return false;\n            else {\n                enqueue(e);\n                return true;\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void put(E e) throws InterruptedException {\n        Objects.requireNonNull(e);\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n        try {\n            // \u68c0\u67e5\u662f\u5426\u5df2\u6ee1\n            while (count == items.length)\n                notFull.await();\n            enqueue(e);\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    private void enqueue(E e) {\n        // assert lock.isHeldByCurrentThread();\n        // assert lock.getHoldCount() == 1;\n        // assert items[putIndex] == null;\n        final Object[] items = this.items;\n        // \u653e\u5165\u6570\u7ec4\n        items[putIndex] = e;\n        if (++putIndex == items.length) putIndex = 0;\n        count++;\n        notEmpty.signal();\n    }\n\n    public E take() throws InterruptedException {\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n        try {\n            while (count == 0)\n                // \u963b\u585e\n                notEmpty.await();\n            return dequeue();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    private E dequeue() {\n        // assert lock.isHeldByCurrentThread();\n        // assert lock.getHoldCount() == 1;\n        // assert items[takeIndex] != null;\n        final Object[] items = this.items;\n        @SuppressWarnings("unchecked")\n        E e = (E) items[takeIndex];\n        // \u7f6e\u7a7a\n        items[takeIndex] = null;\n        if (++takeIndex == items.length) takeIndex = 0;\n        count--;\n        if (itrs != null)\n            itrs.elementDequeued();\n        notFull.signal();\n        return e;\n    }\n\n    public int size() {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            return count;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n')),(0,l.kt)("h3",{id:"linkedblockingqueue"},"LinkedBlockingQueue"),(0,l.kt)("p",null,"\u94fe\u8868\u5b9e\u73b0\u7684\u6709\u754c\u963b\u585e\u961f\u5217"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public class LinkedBlockingQueue<E> extends AbstractQueue<E>\n        implements BlockingQueue<E>, java.io.Serializable {\n\n    private final int capacity;\n    private final AtomicInteger count = new AtomicInteger();\n    transient Node<E> head;\n    private transient Node<E> last;        \n\n    static class Node<E> {\n        E item;\n\n        /**\n         * One of:\n         * - the real successor Node\n         * - this Node, meaning the successor is head.next\n         * - null, meaning there is no successor (this is the last node)\n         */\n        Node<E> next;\n\n        Node(E x) { item = x; }\n    }\n\n    // Integer.MAX_VALUE\n    public LinkedBlockingQueue() {\n        this(Integer.MAX_VALUE);\n    }\n\n    // \u6307\u5b9a\u5bb9\u91cf\n    public LinkedBlockingQueue(int capacity) {\n        if (capacity <= 0) throw new IllegalArgumentException();\n        this.capacity = capacity;\n        last = head = new Node<E>(null);\n    }\n\n    public void put(E e) throws InterruptedException {\n        if (e == null) throw new NullPointerException();\n        final int c;\n        final Node<E> node = new Node<E>(e);\n        final ReentrantLock putLock = this.putLock;\n        final AtomicInteger count = this.count;\n        putLock.lockInterruptibly();\n        try {\n            // \u5224\u65ad\u662f\u5426\u5df2\u6ee1\n            while (count.get() == capacity) {\n                notFull.await();\n            }\n            enqueue(node);\n            c = count.getAndIncrement();\n            if (c + 1 < capacity)\n                notFull.signal();\n        } finally {\n            putLock.unlock();\n        }\n        if (c == 0)\n            signalNotEmpty();\n    }   \n\n    // \u653e\u5165\u5c3e\u90e8\n    private void enqueue(Node<E> node) {\n        last = last.next = node;\n    }    \n\n    public E take() throws InterruptedException {\n        final E x;\n        final int c;\n        final AtomicInteger count = this.count;\n        final ReentrantLock takeLock = this.takeLock;\n        takeLock.lockInterruptibly();\n        try {\n            // \u662f\u5426\u4e3a\u7a7a\n            while (count.get() == 0) {\n                notEmpty.await();\n            }\n            x = dequeue();\n            // \u5143\u7d20\u6570\u91cf\u51cf\u4e00\n            c = count.getAndDecrement();\n            if (c > 1)\n                notEmpty.signal();\n        } finally {\n            takeLock.unlock();\n        }\n        if (c == capacity)\n            signalNotFull();\n        return x;\n    }\n\n    private E dequeue() {\n        // assert takeLock.isHeldByCurrentThread();\n        // assert head.item == null;\n        Node<E> h = head;\n        // \u53d6\u5934\u7ed3\u70b9\u4e0b\u4e00\u4e2a\u8282\u70b9\n        Node<E> first = h.next;\n        h.next = h; // help GC\n        // \u91cd\u65b0\u6307\u5411\u5934\u7ed3\u70b9\n        head = first;\n        E x = first.item;\n        first.item = null;\n        return x;\n    }\n}\n")),(0,l.kt)("h3",{id:"linkedtransferqueue"},"LinkedTransferQueue"),(0,l.kt)("p",null,"\u94fe\u8868\u7ed3\u6784\u7684\u65e0\u754c\u963b\u585e\u961f\u5217"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public class LinkedTransferQueue<E> extends AbstractQueue<E>\n    implements TransferQueue<E>, java.io.Serializable  {\n\n    static final class Node {\n        final boolean isData;   // false if this is a request node\n        volatile Object item;   // initially non-null if isData; CASed to match\n        volatile Node next;\n        volatile Thread waiter; // null when not waiting for a match\n\n        /**\n         * Constructs a data node holding item if item is non-null,\n         * else a request node.  Uses relaxed write because item can\n         * only be seen after piggy-backing publication via CAS.\n         */\n        Node(Object item) {\n            ITEM.set(this, item);\n            isData = (item != null);\n        }\n\n        /** Constructs a (matched data) dummy node. */\n        Node() {\n            isData = true;\n        }\n    }\n}\n")),(0,l.kt)("h3",{id:"linkedblockingdeque"},"LinkedBlockingDeque"),(0,l.kt)("p",null,"\u94fe\u8868\u7ed3\u6784\u7684\u53cc\u5411\u963b\u585e\u961f\u5217"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public class LinkedBlockingDeque<E>\n    extends AbstractQueue<E>\n    implements BlockingDeque<E>, java.io.Serializable {\n\n    static final class Node<E> {\n        /**\n         * The item, or null if this node has been removed.\n         */\n        E item;\n\n        /**\n         * One of:\n         * - the real predecessor Node\n         * - this Node, meaning the predecessor is tail\n         * - null, meaning there is no predecessor\n         */\n        Node<E> prev;\n\n        /**\n         * One of:\n         * - the real successor Node\n         * - this Node, meaning the successor is head\n         * - null, meaning there is no successor\n         */\n        Node<E> next;\n\n        Node(E x) {\n            item = x;\n        }\n    }\n\n    transient Node<E> first;\n    transient Node<E> last;\n     /** Number of items in the deque */\n    private transient int count;\n    /** Maximum number of items in the deque */\n    private final int capacity;\n\n    public LinkedBlockingDeque() {\n        this(Integer.MAX_VALUE);\n    }\n\n    public LinkedBlockingDeque(int capacity) {\n        if (capacity <= 0) throw new IllegalArgumentException();\n        this.capacity = capacity;\n    }\n\n    public boolean offerFirst(E e) {\n        if (e == null) throw new NullPointerException();\n        Node<E> node = new Node<E>(e);\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            return linkFirst(node);\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    private boolean linkFirst(Node<E> node) {\n        // assert lock.isHeldByCurrentThread();\n        if (count >= capacity)\n            return false;\n        Node<E> f = first;\n        node.next = f;\n        first = node;\n        if (last == null)\n            last = node;\n        else\n            f.prev = node;\n        ++count;\n        notEmpty.signal();\n        return true;\n    }\n\n    public E pollFirst() {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            return unlinkFirst();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    private E unlinkFirst() {\n        // assert lock.isHeldByCurrentThread();\n        Node<E> f = first;\n        if (f == null)\n            return null;\n        Node<E> n = f.next;\n        E item = f.item;\n        f.item = null;\n        f.next = f; // help GC\n        first = n;\n        if (n == null)\n            last = null;\n        else\n            n.prev = null;\n        --count;\n        notFull.signal();\n        return item;\n    }\n}\n")),(0,l.kt)("h3",{id:"priorityblockingqueue"},"PriorityBlockingQueue"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Priority ","[pra\u026a\u02c8\u0252r\u0259ti]",", Blocking ","[bl\u0252k\u026a\u014b]"," queue  ","[kju\u02d0]")),(0,l.kt)("p",null,"\u652f\u6301\u4f18\u5148\u7ea7\u7684\u65e0\u754c\u963b\u585e\u961f\u5217"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public class PriorityBlockingQueue<E> extends AbstractQueue<E>\n    implements BlockingQueue<E>, java.io.Serializable {\n    private static final int DEFAULT_INITIAL_CAPACITY = 11;\n    private transient Object[] queue;\n    private transient int size;\n    private transient Comparator<? super E> comparator;\n    private PriorityQueue<E> q;\n\n    // \u9ed8\u8ba4\u5bb9\u91cf\uff0c\u81ea\u7136\u5e8f\u6392\u5217\n    public PriorityBlockingQueue() {\n        this(DEFAULT_INITIAL_CAPACITY, null);\n    }\n\n    // \u6307\u5b9a\u5bb9\u91cf\uff08\u6700\u5c0f\u4e3a1\uff09\n    public PriorityBlockingQueue(int initialCapacity,\n                                 Comparator<? super E> comparator) {\n        if (initialCapacity < 1)\n            throw new IllegalArgumentException();\n        this.comparator = comparator;\n        this.queue = new Object[Math.max(1, initialCapacity)];\n    }\n\n    public void put(E e) {\n        offer(e); // \u4e0d\u9700\u8981\u963b\u585e\n    }\n\n    public boolean offer(E e) {\n        if (e == null)\n            throw new NullPointerException();\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        int n, cap;\n        Object[] es;\n        while ((n = size) >= (cap = (es = queue).length))\n            tryGrow(es, cap);\n        try {\n            final Comparator<? super E> cmp;\n            if ((cmp = comparator) == null)\n                siftUpComparable(n, e, es);\n            else\n                siftUpUsingComparator(n, e, es, cmp);\n            size = n + 1;\n            notEmpty.signal();\n        } finally {\n            lock.unlock();\n        }\n        return true;\n    }\n\n    public E take() throws InterruptedException {\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n        E result;\n        try {\n            while ( (result = dequeue()) == null)\n                notEmpty.await();\n        } finally {\n            lock.unlock();\n        }\n        return result;\n    }\n\n    private E dequeue() {\n        // assert lock.isHeldByCurrentThread();\n        final Object[] es;\n        final E result;\n\n        if ((result = (E) ((es = queue)[0])) != null) {\n            final int n;\n            final E x = (E) es[(n = --size)];\n            es[n] = null;\n            if (n > 0) {\n                final Comparator<? super E> cmp;\n                if ((cmp = comparator) == null)\n                    siftDownComparable(0, x, es, n);\n                else\n                    siftDownUsingComparator(0, x, es, n, cmp);\n            }\n        }\n        return result;\n    }\n}\n")),(0,l.kt)("h3",{id:"delayqueue"},"DelayQueue"),(0,l.kt)("p",null,"\u652f\u6301\u5ef6\u65f6\u83b7\u53d6\u5143\u7d20\u7684\u65e0\u754c\u961f\u5217\uff0c\u961f\u5217\u4e2d\u7684\u5143\u7d20\u9700\u8981\u5b9e\u73b0 ",(0,l.kt)("inlineCode",{parentName:"p"},"Delayed")," \u63a5\u53e3"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"\npublic class DelayQueue<E extends Delayed> extends AbstractQueue<E>\n    implements BlockingQueue<E>{\n    private final PriorityQueue<E> q = new PriorityQueue<E>();\n\n    public DelayQueue() {}\n\n    // \u6dfb\u52a0\u5143\u7d20\n    public boolean offer(E e) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            // \u63d2\u5165\u961f\u5217\u4e2d\n            q.offer(e);\n            if (q.peek() == e) {\n                leader = null;\n                available.signal();\n            }\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public E take() throws InterruptedException {\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n        try {\n            for (;;) {\n                E first = q.peek();\n                // \u5934\u5143\u7d20\u4e3a\u7a7anull\u65f6\u963b\u585e\n                if (first == null)\n                    available.await();\n                else {\n                    // \u5269\u4f59\u5ef6\u8fdf\u65f6\u95f4\n                    long delay = first.getDelay(NANOSECONDS);\n                    if (delay <= 0L)\n                        // \u5f39\u51fa\u5934\u5143\u7d20\n                        return q.poll();\n                    first = null; // don't retain ref while waiting\n                    if (leader != null)\n                        available.await();\n                    else {\n                        Thread thisThread = Thread.currentThread();\n                        leader = thisThread;\n                        try {\n                            available.awaitNanos(delay);\n                        } finally {\n                            if (leader == thisThread)\n                                leader = null;\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (leader == null && q.peek() != null)\n                available.signal();\n            lock.unlock();\n        }\n    }\n}\n")),(0,l.kt)("h4",{id:"priorityqueue"},"PriorityQueue"),(0,l.kt)("p",null,"\u4f18\u5148\u7ea7\u961f\u5217"),(0,l.kt)("p",null,"PriorityQueue \u5e95\u5c42\u901a\u8fc7\u6570\u7ec4\u6765\u5b9e\u73b0\u5143\u7d20\u7684\u5b58\u50a8"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public class PriorityQueue<E> extends AbstractQueue<E>{\n    private static final int DEFAULT_INITIAL_CAPACITY = 11;\n\n    // \u961f\u5217\u7684\u5143\u7d20\u4fdd\u5b58\u5728\u6570\u7ec4queue\u4e2d\uff0c\u5176\u6570\u636e\u7ed3\u6784\u4e3a\u6700\u5c0f\u5806\uff0c\u4e5f\u5c31\u662f\u7528\u6570\u7ec4\u8868\u793a\u7684\u5b8c\u5168\u4e8c\u53c9\u6811\n    transient Object[] queue;\n    int size;\n    transient int modCount;\n\n    public PriorityQueue(int initialCapacity,\n                         Comparator<? super E> comparator) {\n        // Note: This restriction of at least one is not actually needed,\n        // but continues for 1.5 compatibility\n        if (initialCapacity < 1)\n            throw new IllegalArgumentException();\n        this.queue = new Object[initialCapacity];\n        this.comparator = comparator;\n    }\n\n    // \u63d2\u5165\u5143\u7d20\n    public boolean offer(E e) {\n        if (e == null)\n            throw new NullPointerException();\n        // \u4fee\u6539\u6b21\u6570\n        modCount++;\n        int i = size;\n        if (i >= queue.length)\n            grow(i + 1);\n        siftUp(i, e);\n        size = i + 1;\n        return true;\n    }\n\n    private void siftUp(int k, E x) {\n        if (comparator != null)\n            // \u57fa\u4e8ecomparator\u5c5e\u6027\u8fdb\u884c\u5927\u5c0f\u6bd4\u8f83\n            siftUpUsingComparator(k, x, queue, comparator);\n        else\n            // \u6839\u636e\u5143\u7d20\u81ea\u8eab\u8fdb\u884c\u6392\u5e8f\n            siftUpComparable(k, x, queue);\n    }\n\n    private static <T> void siftUpComparable(int k, T x, Object[] es) {\n        Comparable<? super T> key = (Comparable<? super T>) x;\n        while (k > 0) {\n            int parent = (k - 1) >>> 1;\n            Object e = es[parent];\n            if (key.compareTo((T) e) >= 0)\n                break;\n            es[k] = e;\n            k = parent;\n        }\n        es[k] = key;\n    }\n\n    private static <T> void siftUpUsingComparator(\n        int k, T x, Object[] es, Comparator<? super T> cmp) {\n        while (k > 0) {\n            int parent = (k - 1) >>> 1;\n            Object e = es[parent];\n            if (cmp.compare(x, (T) e) >= 0)\n                break;\n            es[k] = e;\n            k = parent;\n        }\n        es[k] = x;\n    }\n\n    // \u6269\u5bb9 \u5c0f\u4e8e64\u6269\u5bb9\u4e24\u500d+2\uff0c\u5426\u5219\u6269\u5bb91.5\u500d\n    private void grow(int minCapacity) {\n        int oldCapacity = queue.length;\n        // Double size if small; else grow by 50%\n        int newCapacity = oldCapacity + ((oldCapacity < 64) ?\n                                         (oldCapacity + 2) :\n                                         (oldCapacity >> 1));\n        // overflow-conscious code\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // \u590d\u5236\u6570\u636e\n        queue = Arrays.copyOf(queue, newCapacity);\n    }\n\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n\n    // \u5934\u5143\u7d20\n    public E peek() {\n        return (E) queue[0];\n    }\n}\n")),(0,l.kt)("h4",{id:"\u5c0f\u9876\u5806"},"\u5c0f\u9876\u5806"),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(3752).Z})),(0,l.kt)("p",null,"\u5143\u7d20\u8282\u70b9\u5173\u7cfb"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"leftNo = parentNo * 2 + 1\nrightNo = parentNo * 2 + 2\nparentNo = (currentNo -1) / 2\n\nparentNo\uff1a\u8868\u793a\u7236\u8282\u70b9\u4e0b\u6807\uff1b\nleftNo\uff1a\u8868\u793a\u5b50\u5143\u7d20\u5de6\u8282\u70b9\u4e0b\u6807\uff1b\nrightNo\uff1a\u8868\u793a\u5b50\u5143\u7d20\u53f3\u8282\u70b9\u4e0b\u6807\uff1b\ncurrentNo\uff1a\u8868\u793a\u5f53\u524d\u5143\u7d20\u8282\u70b9\u4e0b\u6807\uff1b\n")),(0,l.kt)("p",null,"\u901a\u8fc7\u4e0a\u8ff0\u4e09\u4e2a\u516c\u5f0f\uff0c\u53ef\u4ee5\u8f7b\u6613\u8ba1\u7b97\u51fa\u67d0\u4e2a\u8282\u70b9\u7684\u7236\u8282\u70b9\u4ee5\u53ca\u5b50\u8282\u70b9\u7684\u4e0b\u6807"),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(17664).Z})),(0,l.kt)("h2",{id:"\u53c2\u8003"},"\u53c2\u8003"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://blog.csdn.net/qq_38293564/article/details/80798310"},"Java\u5e76\u53d1\u7f16\u7a0b\u4e4bConcurrentLinkedQueue\u8be6\u89e3")),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://www.cnblogs.com/dxflqm/p/12067265.html"},"\u6df1\u5165\u6d45\u51fa\u5206\u6790 PriorityQueue")))}p.isMDXComponent=!0},6242:function(n,e,t){"use strict";e.Z=t.p+"assets/images/ConcurrentLinkedQueue-df6dd5aa5b04a54d1b05c9da27c4e841.png"},49659:function(n,e,t){"use strict";e.Z=t.p+"assets/images/CopyOnWriteArrayList-b850551cbe36bf1acd54acfe4c221245.png"},3752:function(n,e,t){"use strict";e.Z=t.p+"assets/images/1078540-20191219134028689-155327191-0f0075db90108270be9d753639416663.png"},17664:function(n,e,t){"use strict";e.Z=t.p+"assets/images/1078540-20191219134058870-285989691-a01a249edd93790d561db70cc67d472b.png"},32088:function(n,e,t){"use strict";e.Z=t.p+"assets/images/1162587-20190217130653916-1383228669-83d3407356d1aa2a0e47cae207a2dfc3.png"},52044:function(n,e,t){"use strict";e.Z=t.p+"assets/images/ConcurrentHashMap-4d91e2e7d773b275171bf9cca2bfeab0.png"}}]);