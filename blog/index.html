<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.75">
<link rel="alternate" type="application/rss+xml" href="/docs.advanced.way/blog/rss.xml" title="进阶之路 Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/docs.advanced.way/blog/atom.xml" title="进阶之路 Blog Atom Feed"><title data-react-helmet="true">Blog | 进阶之路</title><meta data-react-helmet="true" property="og:title" content="Blog | 进阶之路"><meta data-react-helmet="true" name="description" content="Blog"><meta data-react-helmet="true" property="og:description" content="Blog"><meta data-react-helmet="true" property="og:url" content="https://Goldwood1024.github.io/docs.advanced.way/blog"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="blog_posts_list"><link data-react-helmet="true" rel="shortcut icon" href="/docs.advanced.way/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Goldwood1024.github.io/docs.advanced.way/blog"><link data-react-helmet="true" rel="alternate" href="https://Goldwood1024.github.io/docs.advanced.way/blog" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Goldwood1024.github.io/docs.advanced.way/blog" hreflang="x-default"><link rel="stylesheet" href="/docs.advanced.way/assets/css/styles.5e159b62.css">
<link rel="preload" href="/docs.advanced.way/assets/js/runtime~main.871cb501.js" as="script">
<link rel="preload" href="/docs.advanced.way/assets/js/main.9348fd2a.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top navbarHideable_2qcr"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/docs.advanced.way/"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">进阶之路</strong></a><a class="navbar__item navbar__link" href="/docs.advanced.way/docs/java/">Java</a><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link">生态</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/spring-family/">Spring家族</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/framework/mybatis/">常用框架</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/distributed/">分布式</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/cloud/docker/base/镜像/">容器</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/db/mysql/InnoDB/">数据库</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/os/network/tcpip/">计算机系统</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link">编码实践</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs.advanced.way/docs/algorithm/algorithm/">算法/数据结构</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/patterns/">设计模式</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/architecture/">系统架构</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/practice/memo/tool/sublime/">备忘录</a></li></ul></div></div><div class="navbar__items navbar__items--right"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs.advanced.way/blog">博客</a><a href="https://github.com/Goldwood1024/docs.advanced.way.git" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/docs.advanced.way/"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">进阶之路</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/java/">Java</a></li><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist">生态</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/spring-family/">Spring家族</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/framework/mybatis/">常用框架</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/distributed/">分布式</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/cloud/docker/base/镜像/">容器</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/db/mysql/InnoDB/">数据库</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/os/network/tcpip/">计算机系统</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist">编码实践</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/algorithm/algorithm/">算法/数据结构</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/patterns/">设计模式</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/architecture/">系统架构</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/practice/memo/tool/sublime/">备忘录</a></li></ul></li><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs.advanced.way/blog">博客</a></li><li class="menu__list-item"><a href="https://github.com/Goldwood1024/docs.advanced.way.git" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper blog-wrapper blog-list-page"><div class="container margin-vert--lg"><div class="row"><div class="col col--3"><div class="sidebar_2ahu thin-scrollbar"><h3 class="sidebarItemTitle_2hhb">Recent posts</h3><ul class="sidebarItemList_2xAf"><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/docs.advanced.way/blog/Distributed-consensus-algorithm">分布式共识算法</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/docs.advanced.way/blog/cache-pattern">缓存模型</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/docs.advanced.way/blog/mysql-log">Mysql 日志文件</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/docs.advanced.way/blog/Hash-Flooding">哈希洪水攻击</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/docs.advanced.way/blog/hash">Hash算法</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/docs.advanced.way/blog/redis.ae">redis 事件模型</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/docs.advanced.way/blog/transaction">事务</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/docs.advanced.way/blog/id">唯一Id生成规则</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/docs.advanced.way/blog/mysql">mysql 进程常见的 State</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/docs.advanced.way/blog/mysql">mysql 常用片段</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/docs.advanced.way/blog/recover-macoos">macOS 恢复</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/docs.advanced.way/blog/vuepess-upgrade-docusaurus">Vuepress 升级到 Docusaurus</a></li></ul></div></div><main class="col col--7"><article class="margin-bottom--xl"><header><h2 class="margin-bottom--sm blogPostTitle_GeHD"><a href="/docs.advanced.way/blog/Distributed-consensus-algorithm">分布式共识算法</a></h2><div class="margin-vert--md"><time datetime="2021-06-03T00:00:00.000Z" class="blogPostDate_fNvV">June 3, 2021 · 2 min read</time></div><div class="avatar margin-vert--md"><div class="avatar__intro"></div></div></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="一致性"></a>一致性<a class="hash-link" href="#一致性" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="cap-theorem（cap-理论）"></a>CAP theorem（CAP 理论）<a class="hash-link" href="#cap-theorem（cap-理论）" title="Direct link to heading">#</a></h3><p><img src="/docs.advanced.way/assets/images/285763-20190621144256061-464757033-bc0f46c124fe87f882a10ef63cf3d40c.png"></p><ul><li>一致性（Consistency）</li><li>可用性（Availability）</li><li>分区容错性（Partition tolerance）</li></ul><p>以上三个特性，同一时刻不能同时满足</p><blockquote><p>在分布式系统的设计中，没有一种设计可以同时满足一致性，可用性，分区容错性 3个特性</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="base-理论"></a>Base 理论<a class="hash-link" href="#base-理论" title="Direct link to heading">#</a></h3><p>BASE(Basically Available, Soft State, Eventual Consistency  基本可用、软状态、最终一致性) 对CAP AP理论的延伸</p><p>核心思想
即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="一致性模型"></a>一致性模型<a class="hash-link" href="#一致性模型" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="弱一致性模型"></a>弱一致性模型<a class="hash-link" href="#弱一致性模型" title="Direct link to heading">#</a></h4><p>这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态</p><ul><li>DNS（Domain Name System）</li><li>Gossip(Cassandra的通信协议)</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="强一致性模型"></a>强一致性模型<a class="hash-link" href="#强一致性模型" title="Direct link to heading">#</a></h4><ul><li>同步</li><li>Paxos</li><li>Ratf(multi-paxos)</li><li>ZAB(multi-paxos)</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="最终一致性模型"></a>最终一致性模型<a class="hash-link" href="#最终一致性模型" title="Direct link to heading">#</a></h4><p>最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="raft-算法"></a>Raft 算法<a class="hash-link" href="#raft-算法" title="Direct link to heading">#</a></h2><blockquote><p>Raft [rɑ:ft] 实现了和Paxos相同的功能，它将一致性分解为多个子问题</p><ul><li>Leader选举（Leader election）</li><li>日志同步（Log replication）</li><li>安全性（Safety）</li><li>日志压缩（Log compaction）</li><li>成员变更（Membership change）</li></ul></blockquote><p>Raft要求系统在任意时刻最多只有一个Leader，正常工作期间只有Leader和Followers</p><ul><li>Leader 接受客户端请求，并向Follower 同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志</li><li>Follower 接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志</li><li>Candidate 候选人 Leader选举过程中的临时角色</li></ul><p>状态切换图:</p><p><img src="/docs.advanced.way/assets/images/v2-7f64a2df8f8817932ed047d35878bca9_1440w-c46ff4b9ba8ea058277aed7e4902ce6e.jpg"></p><p>Leader在宕机之前会一直保持Leader的状态</p><p>任期: </p><p><img src="/docs.advanced.way/assets/images/v2-d3cc1cb525ac72dc59ed34148cb3199c_1440w-bca2045247a54d4fbc42dcb7d0019664.png">
Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="leader选举"></a>Leader选举<a class="hash-link" href="#leader选举" title="Direct link to heading">#</a></h3><p>使用心跳（heartbeat）触发Leader选举，选举出Leader后，Leader通过定期向所有Followers发送心跳信息维持其统治</p><p>选举过程:</p><ol><li>当服务器启动时，初始化为Follower</li><li>Leader向所有Followers周期性发送heartbeat </li><li>如果Follower在选举超时时间内没有收到Leader的heartbeat，就会等待一段随机的时间后发起一次Leader选举</li><li>Follower将其当前term加一然后转换为Candidate</li><li>首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC</li></ol><p>选举结果会出现的情况:</p><ol><li>赢得了多数的选票，成功选举为Leader</li><li>收到了Leader的消息，表示有其它服务器已经抢先当选了Leader</li><li>没有服务器赢得多数的选票，Leader选举失败，等待选举时间超时后发起下一次选举</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="日志同步"></a>日志同步<a class="hash-link" href="#日志同步" title="Direct link to heading">#</a></h3><p>Leader把请求作为日志条目（Log entries）加入到它的日志中，然后并行的向其他服务器发起 AppendEntries RPC 复制日志条目。
当这条日志被复制到大多数服务器上，Leader将这条日志应用到它的状态机并向客户端返回执行结果</p><p><img src="/docs.advanced.way/assets/images/v2-ee29a89e4eb63468e142bb6103dbe4de_1440w-9f8017c8f21b06b193f72b034817ccf5.jpg"></p><p>日志由有序编号（log index）的日志条目组成。每个日志条目包含它被创建时的任期号（term），和用于状态机执行的命令。如果一个日志条目被复制到大多数服务器上，就被认为可以提交（commit）</p><p>Raft日志同步保证如下两点：</p><ul><li>如果不同日志中的两个条目有着相同的索引和任期号，则它们所存储的命令是相同的。</li><li>如果不同日志中的两个条目有着相同的索引和任期号，则它们之前的所有条目都是完全一样的。</li></ul><p><img alt="Leader和Followers上日志不一致" src="/docs.advanced.way/assets/images/v2-d36c587901391cae50788061f568d24f_1440w-976eaf86abdf5f43ecf9adc4cf86993b.jpg"></p><p>上图阐述了一些Followers可能和新的Leader日志不同的情况。一个Follower可能会丢失掉Leader上的一些条目，也有可能包含一些Leader没有的条目，也有可能两者都会发生。丢失的或者多出来的条目可能会持续多个任期。</p><p>Leader通过强制Followers复制它的日志来处理日志的不一致，Followers上的不一致的日志会被Leader的日志覆盖。</p><p>Leader为了使Followers的日志同自己的一致，Leader需要找到Followers同它的日志一致的地方，然后覆盖Followers在该位置之后的条目。</p><p>Leader会从后往前试，每次AppendEntries失败后尝试前一个日志条目，直到成功找到每个Follower的日志一致位点，然后向后逐条覆盖Followers在该位置之后的条目</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="安全性"></a>安全性<a class="hash-link" href="#安全性" title="Direct link to heading">#</a></h3><ul><li>拥有最新的已提交的log entry的Follower才有资格成为Leader<blockquote><p>这个保证是在RequestVote RPC中做的，Candidate在发送RequestVote RPC时，要带上自己的最后一条日志的term和log index，其他节点收到消息时，如果发现自己的日志比请求中携带的更新，则拒绝投票。日志比较的原则是，如果本地的最后一条log entry的term更大，则term大的更新，如果term一样大，则log index更大的更新</p></blockquote></li><li>Leader只能推进commit index来提交当前term的已经复制到大多数服务器上的日志，旧term日志的提交要等到提交当前term的日志来间接提交（log index 小于 commit index的日志被间接提交）</li></ul><p><img alt="已提交的日志被覆盖" src="/docs.advanced.way/assets/images/v2-12a5ebab63781f9ec49e14e331775537_1440w-c7c6f7f7e77c1d8bfd5f0c6b8b6ef94e.jpg"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="日志压缩"></a>日志压缩<a class="hash-link" href="#日志压缩" title="Direct link to heading">#</a></h3><p>在实际的系统中，不能让日志无限增长，否则系统重启时需要花很长的时间进行回放，从而影响可用性。
Raft采用对整个系统进行snapshot来解决，snapshot之前的日志都可以丢弃</p><p>每个副本独立的对自己的系统状态进行snapshot，并且只能对已经提交的日志记录进行snapshot</p><p>日志内容:</p><ul><li><p>日志元数据</p><blockquote><p>最后一条已提交的 log entry的 log index和term。
这两个值在snapshot之后的第一条log entry的AppendEntries RPC的完整性检查的时候会被用上。</p></blockquote></li><li><p>系统当前状态</p></li></ul><p>当新加进一台机器时，也会发送snapshot给它。发送snapshot使用InstalledSnapshot RPC</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="成员变更"></a>成员变更<a class="hash-link" href="#成员变更" title="Direct link to heading">#</a></h3><p>成员变更是在集群运行过程中副本发生变化，如增加/减少副本数、节点替换等</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="raft算法总结"></a>Raft算法总结<a class="hash-link" href="#raft算法总结" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="各节点维护的状态"></a>各节点维护的状态<a class="hash-link" href="#各节点维护的状态" title="Direct link to heading">#</a></h4><p><img alt="各节点维护的状态" src="/docs.advanced.way/assets/images/v2-9b53bd65fa9e11eeefd5331833d41c78_1440w-9f83203837ed63e89ef6dbac94eeabe3.jpg"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="leader选举-1"></a>Leader选举<a class="hash-link" href="#leader选举-1" title="Direct link to heading">#</a></h4><p><img alt="Leader选举" src="/docs.advanced.way/assets/images/v2-05b80ce9095004381b5846c6179f932e_1440w-eb126ecb52d8ba2641aa52650033fa40.jpg"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="日志同步-1"></a>日志同步<a class="hash-link" href="#日志同步-1" title="Direct link to heading">#</a></h4><p><img alt="Leader选举" src="/docs.advanced.way/assets/images/v2-8713b773762e9644c38defa5086afacd_1440w-44fefc2c7616001766a0ea932ae92452.jpg"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="raft状态机"></a>Raft状态机<a class="hash-link" href="#raft状态机" title="Direct link to heading">#</a></h4><p><img alt="Raft状态机" src="/docs.advanced.way/assets/images/v2-4abb923772ec1be269843c977b5af3c8_1440w-58fd608ac9e6cfa30863dd1638e3afc7.jpg"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="安装snapshot"></a>安装snapshot<a class="hash-link" href="#安装snapshot" title="Direct link to heading">#</a></h4><p><img alt="安装snapshot" src="/docs.advanced.way/assets/images/v2-793f4024bfcb648d9aab2a3dfe6b80de_1440w-ecdf769da625e23b2555c66a63dfceb6.jpg"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="paxos-算法"></a>Paxos 算法<a class="hash-link" href="#paxos-算法" title="Direct link to heading">#</a></h2><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="zab-算法"></a>ZAB 算法<a class="hash-link" href="#zab-算法" title="Direct link to heading">#</a></h2><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="相关文档"></a>相关文档<a class="hash-link" href="#相关文档" title="Direct link to heading">#</a></h2><ul><li><a href="https://raft.github.io" target="_blank" rel="noopener noreferrer">The Raft Consensus Algorithm 实现库</a></li><li><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener noreferrer">raft 动画演示</a></li><li><a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener noreferrer">raft 论文</a></li><li><a href="https://github.com/maemual/raft-zh_cn" target="_blank" rel="noopener noreferrer">raft 论文中文翻译</a></li><li><a href="https://zhuanlan.zhihu.com/p/32052223" target="_blank" rel="noopener noreferrer">raft 相关文章</a></li></ul></div><footer class="row margin-vert--lg"><div class="col"><strong>Tags:</strong><a class="margin-horiz--sm" href="/docs.advanced.way/blog/tags/分布式共识算法">分布式共识算法</a><a class="margin-horiz--sm" href="/docs.advanced.way/blog/tags/distributed">Distributed</a><a class="margin-horiz--sm" href="/docs.advanced.way/blog/tags/consensus">consensus</a><a class="margin-horiz--sm" href="/docs.advanced.way/blog/tags/algorithm">algorithm</a><a class="margin-horiz--sm" href="/docs.advanced.way/blog/tags/cap">CAP</a><a class="margin-horiz--sm" href="/docs.advanced.way/blog/tags/paxos">Paxos</a><a class="margin-horiz--sm" href="/docs.advanced.way/blog/tags/raft">Raft</a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="margin-bottom--sm blogPostTitle_GeHD"><a href="/docs.advanced.way/blog/cache-pattern">缓存模型</a></h2><div class="margin-vert--md"><time datetime="2021-06-03T00:00:00.000Z" class="blogPostDate_fNvV">June 3, 2021 · One min read</time></div><div class="avatar margin-vert--md"><div class="avatar__intro"></div></div></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="缓存模型"></a>缓存模型<a class="hash-link" href="#缓存模型" title="Direct link to heading">#</a></h2><p>缓存可以提升性能、缓解数据库压力，但是使用缓存也会导致数据不一致性的问题。</p><p>经典的缓存使用模式: </p><ul><li>Cache-Aside Pattern</li><li>Read-Through/Write-through</li><li>Write-behind</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="cache-aside-pattern"></a>Cache-Aside Pattern<a class="hash-link" href="#cache-aside-pattern" title="Direct link to heading">#</a></h3><p>旁路缓存模式，它的提出是为了尽可能地解决缓存与数据库的数据不一致问题</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="读流程"></a>读流程<a class="hash-link" href="#读流程" title="Direct link to heading">#</a></h4><p><img src="/docs.advanced.way/assets/images/b93293bab20f7503950b730594703a53-a8ba3b9f2ff7d19f1baa42ad8abbba49.jpg"></p><ol><li>先读缓存，缓存命中，直接返回数据</li><li>缓存没有命中，读数据库</li><li>从数据库取出数据，放入缓存后</li><li>返回响应</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="写流程"></a>写流程<a class="hash-link" href="#写流程" title="Direct link to heading">#</a></h4><p><strong>先更新数据库，然后再删除缓存</strong></p><blockquote><p>防止并发场景，数据不一致</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="read-throughwrite-through"></a>Read-Through/Write-Through<a class="hash-link" href="#read-throughwrite-through" title="Direct link to heading">#</a></h3><p>Read/Write-Through(读写穿透) 模式中，服务端把缓存作为主要数据存储。
应用程序跟数据库缓存交互，都是通过抽象缓存层完成</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="读流程-1"></a>读流程<a class="hash-link" href="#读流程-1" title="Direct link to heading">#</a></h4><p><img src="/docs.advanced.way/assets/images/7b8ca8721e5f7da70376875f14e96cfb-c69626b4aa5a96d8352f3f64dc90504e.jpg"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="写流程-1"></a>写流程<a class="hash-link" href="#写流程-1" title="Direct link to heading">#</a></h4><p><img src="/docs.advanced.way/assets/images/504b11c77f6a8609f09f23fac659c4da-4c6b4207c8f1ea103d34523eba5c1c4f.jpg"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="write-behind"></a>Write-behind<a class="hash-link" href="#write-behind" title="Direct link to heading">#</a></h3><p>Write-Behind则是只更新缓存，不直接更新数据库，通过<strong>批量异步</strong>的方式来更新数据库</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="流程"></a>流程<a class="hash-link" href="#流程" title="Direct link to heading">#</a></h4><p><img src="/docs.advanced.way/assets/images/fb33e93d464712d06b8b7c1b5b771ba8-e8d9bd399268f6802ab99a1398353ba1.jpg"></p><p>这种方式下，缓存和数据库的一致性不强，对一致性要求高的系统要谨慎使用</p><blockquote><p>适合频繁写的场景，<code>MySQL</code> 的 <code>InnoDB Buffer Pool</code> 机制就使用到这种模式</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="场景1-操作缓存的时候，到底是删除缓存呢，还是更新缓存"></a>场景1 操作缓存的时候，到底是删除缓存呢，还是更新缓存<a class="hash-link" href="#场景1-操作缓存的时候，到底是删除缓存呢，还是更新缓存" title="Direct link to heading">#</a></h3><p><img src="/docs.advanced.way/assets/images/69fe5712c096ade14e2e3b9b1270fcf2-aa0fc527f769db362445a6efa2192a51.jpg"></p><ol><li>线程A先发起一个写操作，第一步先更新数据库</li><li>线程B再发起一个写操作，第二步更新了数据库</li><li>由于网络等原因，线程B先更新了缓存</li><li>线程A更新缓存</li></ol><p>这时候，缓存保存的是A的数据（老数据），数据库保存的是B的数据（新数据），数据不一致了，脏数据出现啦。</p><p>如果是删除缓存取代更新缓存则不会出现这个脏数据问题</p><blockquote><p>更新缓存相对于删除缓存，还有两点劣势:</p><ul><li>如果你写入的缓存值，是经过复杂计算才得到的话。更新缓存频率高的话，就浪费性能啦。</li><li>在写数据库场景多，读数据场景少的情况下，数据很多时候还没被读取到，又被更新了，这也浪费了性能呢(实际上，写多的场景，用缓存也不是很划算的,哈哈)</li></ul></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="场景2-双写的情况下，先操作数据库还是先操作缓存？"></a>场景2 双写的情况下，先操作数据库还是先操作缓存？<a class="hash-link" href="#场景2-双写的情况下，先操作数据库还是先操作缓存？" title="Direct link to heading">#</a></h3><p>先操作数据库</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="场景3-删除缓存失败如何处理"></a>场景3 删除缓存失败如何处理<a class="hash-link" href="#场景3-删除缓存失败如何处理" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="缓存延时双删"></a>缓存延时双删<a class="hash-link" href="#缓存延时双删" title="Direct link to heading">#</a></h4><ol><li>先删除缓存</li><li>更新数据库</li><li>休眠一会，在删除缓存</li></ol><blockquote><p>休眠时间 = 读业务逻辑数据的耗时 + 几百毫秒</p></blockquote><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="删除缓存重试机制"></a>删除缓存重试机制<a class="hash-link" href="#删除缓存重试机制" title="Direct link to heading">#</a></h4><ul><li>写请求更新数据库</li><li>缓存因为某些原因，删除失败</li><li>把删除失败的key放到MQ</li><li>消费MQ的消息，获取要删除的key</li><li>重试删除缓存操作</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="读取biglog异步删除缓存"></a>读取biglog异步删除缓存<a class="hash-link" href="#读取biglog异步删除缓存" title="Direct link to heading">#</a></h4><p><img src="/docs.advanced.way/assets/images/9fe12b61c540cd6435a45d1603e5f727-aca5ad084c0ea16634631351aa754524.jpg"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="相关文档"></a>相关文档<a class="hash-link" href="#相关文档" title="Direct link to heading">#</a></h2><ul><li><a href="https://mp.weixin.qq.com/s/ZTCbrR65Xyr23xAp36_wcw" target="_blank" rel="noopener noreferrer">Redis与MySQL双写一致性如何保证</a></li></ul></div><footer class="row margin-vert--lg"><div class="col"><strong>Tags:</strong><a class="margin-horiz--sm" href="/docs.advanced.way/blog/tags/缓存模型">缓存模型</a><a class="margin-horiz--sm" href="/docs.advanced.way/blog/tags/cache">cache</a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="margin-bottom--sm blogPostTitle_GeHD"><a href="/docs.advanced.way/blog/mysql-log">Mysql 日志文件</a></h2><div class="margin-vert--md"><time datetime="2021-06-03T00:00:00.000Z" class="blogPostDate_fNvV">June 3, 2021 · One min read</time></div><div class="avatar margin-vert--md"><div class="avatar__intro"></div></div></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="文件分类"></a>文件分类<a class="hash-link" href="#文件分类" title="Direct link to heading">#</a></h2><table><thead><tr><th>日志类型</th><th>写入日志的信息</th></tr></thead><tbody><tr><td>错误日志</td><td>记录在启动，运行或停止mysqld时遇到的问题</td></tr><tr><td>通用查询日志</td><td>记录建立的客户端连接和执行的语句</td></tr><tr><td>二进制日志</td><td>记录更改数据的语句</td></tr><tr><td>中继日志</td><td>从复制主服务器接收的数据更改</td></tr><tr><td>慢查询日志</td><td>记录所有执行时间超过 long_query_time 秒的所有查询或不使用索引的查询</td></tr><tr><td>DDL日志（元数据日志）</td><td>元数据操作由DDL语句执行</td></tr></tbody></table><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="二进制日志binlog"></a>二进制日志(binlog)<a class="hash-link" href="#二进制日志binlog" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="文件格式"></a>文件格式<a class="hash-link" href="#文件格式" title="Direct link to heading">#</a></h3><ul><li>STATEMENT: 基于SQL语句的复制（statement-based replication, SBR）</li><li>ROW: 基于行的复制（row-based replication, RBR）</li><li>MIXED: 混合模式复制（mixed-based replication, MBR）</li></ul><blockquote><p><code>MySQL 5.7.7</code> 之前，默认的格式是 <code>STATEMENT</code>，在 <code>MySQL 5.7.7</code> 及更高版本中，默认值是 ROW。
日志格式通过 binlog-format 指定, binlog-format=STATEMENT/ROW/MIXED</p></blockquote><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="statement"></a>STATEMENT<a class="hash-link" href="#statement" title="Direct link to heading">#</a></h4><p>每一条会修改数据的sql都会记录在binlog中</p><p>优点:</p><p>不需要记录每一行的变化，减少了binlog日志量，节约了IO, 提高了性能。</p><p>缺点:
由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行的时候相同的结果。
另外mysql的复制，像一些特定函数的功能，slave与master要保持一致会有很多相关问题</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="row"></a>Row<a class="hash-link" href="#row" title="Direct link to heading">#</a></h4><p>不记录sql语句上下文相关信息，仅保存哪条记录被修改后的数据</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="mixed"></a>Mixed<a class="hash-link" href="#mixed" title="Direct link to heading">#</a></h4><p>结合 STATEMENT和Row，在Mixed模式下，一般的语句修改使用statment格式保存binlog，如一些函数。
statement无法完成主从复制的操作，则采用row格式保存binlog
MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种</p></div><footer class="row margin-vert--lg"><div class="col"><strong>Tags:</strong><a class="margin-horiz--sm" href="/docs.advanced.way/blog/tags/mysql">mysql</a><a class="margin-horiz--sm" href="/docs.advanced.way/blog/tags/日志文件">日志文件</a><a class="margin-horiz--sm" href="/docs.advanced.way/blog/tags/binlog">binlog</a></div></footer></article><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs.advanced.way/blog/page/2"><div class="pagination-nav__label">Older Entries »</div></a></div></nav></main></div></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 进阶之路, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/docs.advanced.way/assets/js/runtime~main.871cb501.js"></script>
<script src="/docs.advanced.way/assets/js/main.9348fd2a.js"></script>
</body>
</html>