<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.75">
<link rel="alternate" type="application/rss+xml" href="/docs.advanced.way/blog/rss.xml" title="进阶之路 Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/docs.advanced.way/blog/atom.xml" title="进阶之路 Blog Atom Feed"><title data-react-helmet="true">Map | 进阶之路</title><meta data-react-helmet="true" property="og:url" content="https://Goldwood1024.github.io/docs.advanced.way/docs/java/collection/Map"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Map | 进阶之路"><meta data-react-helmet="true" name="description" content="Map.class"><meta data-react-helmet="true" property="og:description" content="Map.class"><link data-react-helmet="true" rel="shortcut icon" href="/docs.advanced.way/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Goldwood1024.github.io/docs.advanced.way/docs/java/collection/Map"><link data-react-helmet="true" rel="alternate" href="https://Goldwood1024.github.io/docs.advanced.way/docs/java/collection/Map" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Goldwood1024.github.io/docs.advanced.way/docs/java/collection/Map" hreflang="x-default"><link rel="stylesheet" href="/docs.advanced.way/assets/css/styles.5e159b62.css">
<link rel="preload" href="/docs.advanced.way/assets/js/runtime~main.aa1c8b94.js" as="script">
<link rel="preload" href="/docs.advanced.way/assets/js/main.8fae9188.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top navbarHideable_2qcr"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/docs.advanced.way/"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">进阶之路</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs.advanced.way/docs/java/">Java</a><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link">生态</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/spring-family/">Spring家族</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/framework/mybatis/">常用框架</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/distributed/">分布式</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/cloud/docker/base/镜像/">容器</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/db/mysql/InnoDB/">数据库</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/os/network/tcpip/">计算机系统</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link">编码实践</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs.advanced.way/docs/algorithm/algorithm/">算法/数据结构</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/patterns/">设计模式</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/architecture/">系统架构</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/practice/memo/tool/sublime/">备忘录</a></li></ul></div></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/docs.advanced.way/blog">博客</a><a href="https://github.com/Goldwood1024/docs.advanced.way.git" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/docs.advanced.way/"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">进阶之路</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs.advanced.way/docs/java/">Java</a></li><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist">生态</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/spring-family/">Spring家族</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/framework/mybatis/">常用框架</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/distributed/">分布式</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/cloud/docker/base/镜像/">容器</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/db/mysql/InnoDB/">数据库</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/os/network/tcpip/">计算机系统</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist">编码实践</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/algorithm/algorithm/">算法/数据结构</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/patterns/">设计模式</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/architecture/">系统架构</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/practice/memo/tool/sublime/">备忘录</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/blog">博客</a></li><li class="menu__list-item"><a href="https://github.com/Goldwood1024/docs.advanced.way.git" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo sidebarWithHideableNavbar_267A"><a tabindex="-1" class="sidebarLogo_3h0W" href="/docs.advanced.way/"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--dark_hz6m"><strong>进阶之路</strong></a><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">基础</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/">简介</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/object">面向对象</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/数据类型">数据类型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/关键字">关键字</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/String">String</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/io">I/O</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/nio">NIO</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/Reference">对象引用</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/代理">代理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/函数式接口">函数式接口</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/反射">反射</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/base64">Base64编码</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/jdk">JDK</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">集合</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/collection/Collection">Collection</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/collection/List">List</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs.advanced.way/docs/java/collection/Map">Map</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">高并发</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/hc/高并发">高并发</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/hc/多线程">多线程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/hc/并发编程的艺术">并发编程的艺术</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/hc/内存模型">内存模型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/hc/原子类">原子类</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/hc/并发容器">并发容器</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/hc/并发工具类">并发工具类</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/hc/线程池">线程池</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/hc/锁">锁</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">JVM</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/对象创建过程">对象创建过程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/对象回收机制">对象回收机制</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/jvm参数">JVM参数</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/jvm内存模型">内存模型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/内存优化">内存优化</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/垃圾收集器">垃圾收集器</a></li></ul></li></ul></div><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_1CGd"><svg width="20" height="20" role="img" class="collapseSidebarButtonIcon_3E-R"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">Map</h1></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="mapclass"></a>Map.class<a class="hash-link" href="#mapclass" title="Direct link to heading">#</a></h2><p>HashMap是Map接口基于哈希表的实现。
这种实现提供了所有可选的Map操作，并允许key和value为null（除了HashMap是unsynchronized的和允许使用null外，HashMap和HashTable大致相同。）。</p><p>不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p>此实现假设哈希函数在桶内适当地分布元素，为基本实现(get 和 put)提供了稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。如果遍历操作很重要，就不要把初始化容量initial capacity设置得太高（或将加载因子load factor设置得太低），否则会严重降低遍历的效率。</p><p>HashMap有两个影响性能的重要参数：初始化容量 <code>initial capacity</code> 、加载因子 <code>load factor</code>。</p><ul><li>容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。</li><li>加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。</li></ul><p>initial capacity <em> load factor 就是当前允许的最大元素数目，超过initial capacity</em>load factor之后，HashMap就会进行rehashed操作来进行扩容，扩容后的的容量为之前的两倍。</p><p>通常，默认加载因子 (0.75) 在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap类的操作中，包括 get 和 put 操作，都反映了这一点）。</p><p>在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少rehash操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生rehash 操作。</p><p>如果很多映射关系要存储在 HashMap 实例中，则相对于按需执行自动的 rehash 操作以增大表的容量来说，使用足够大的初始容量创建它将使得映射关系能更有效地存储。
注意，此实现不是同步的。如果多个线程同时访问一个哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。（结构上的修改是指添加或删除一个或多个映射关系的任何操作；仅改变与实例已经包含的键关联的值不是结构上的修改。）这一般通过对自然封装该映射的对象进行同步操作来完成。</p><p>如果不存在这样的对象，则应该使用 Collections.synchronizedMap 方法来“包装”该映射。最好在创建时完成这一操作，以防止对映射进行意外的非同步访问，
如下所示：
Map m = Collections.synchronizedMap(new HashMap(…));</p><p>由所有此类的“collection 视图方法”所返回的迭代器都是fail-fast 的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的remove方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。</p><p>因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。</p><p>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。</p><p>因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测bug。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public interface Map&lt;K, V&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    int size();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    boolean isEmpty();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    boolean containsKey(Object key);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    boolean containsValue(Object value);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    V get(Object key);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    V put(K key, V value);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    V remove(Object key);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    void putAll(Map&lt;? extends K, ? extends V&gt; m);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    void clear();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    Set&lt;K&gt; keySet();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    Collection&lt;V&gt; values();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    boolean equals(Object o);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    int hashCode();</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    interface Entry&lt;K, V&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        K getKey();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        V getValue();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        V setValue(V value);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        boolean equals(Object o);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int hashCode();</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 比较器</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                (c1, c2) -&gt; c1.getKey().compareTo(c2.getKey());</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        public static &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? super K&gt; cmp) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Objects.requireNonNull(cmp);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                (c1, c2) -&gt; cmp.compare(c1.getKey(), c2.getKey());</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        public static &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? super V&gt; cmp) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Objects.requireNonNull(cmp);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                (c1, c2) -&gt; cmp.compare(c1.getValue(), c2.getValue());</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="嵌套接口"></a>嵌套接口<a class="hash-link" href="#嵌套接口" title="Direct link to heading">#</a></h3><ul><li>它是逻辑分组仅在一个地方使用的接口的一种方式。</li><li>它增加了封装。</li><li>嵌套接口可以导致更易读和可维护的代码。</li><li>内部接口都是静态的</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="hashmapclass"></a>HashMap.class<a class="hash-link" href="#hashmapclass" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="架构图"></a>架构图<a class="hash-link" href="#架构图" title="Direct link to heading">#</a></h3><p><img src="/docs.advanced.way/assets/images/hashmap-b2c22311915bd05b96fa02db891a68f4.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="数据结构"></a>数据结构<a class="hash-link" href="#数据结构" title="Direct link to heading">#</a></h3><p><img src="/docs.advanced.way/assets/images/88585920190516171536728-de5661ab6859c167cd98df548395b71a.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="源码"></a>源码<a class="hash-link" href="#源码" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    implements Map&lt;K,V&gt;, Cloneable, Serializable {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    </span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 初始容器大小 16</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 容器最大容量</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 负载因子</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final float DEFAULT_LOAD_FACTOR = 0.75f;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 树化阀值</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final int TREEIFY_THRESHOLD = 8;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 恢复成链式结构的桶大小临界值</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final int UNTREEIFY_THRESHOLD = 6;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 当哈希表的大小超过这个阈值，才会把链式结构转化成树型结构，否则仅采取扩容来尝试减少冲突。</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 应该至少 4 * TREEIFY_THRESHOLD 来避免扩容和树形结构化之间的冲突</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 原因: 数组的性能好于数结构</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final int MIN_TREEIFY_CAPACITY = 64;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 容器数组</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    transient Node&lt;K,V&gt;[] table;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 实际存储的key-value键值对的个数</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    transient int size;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 修改次数</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    transient int modCount;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 临界值 threshold= capacity*loadFactory</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    int threshold;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 加载因子默认为0.75, 实际元素比 大于loadFactor则扩容</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    final float loadFactor;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final int hash;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final K key;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        V value;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;K,V&gt; next;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node(int hash, K key, V value, Node&lt;K,V&gt; next) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            this.hash = hash;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            this.key = key;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            this.value = value;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            this.next = next;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        public final K getKey()        { return key; }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        public final V getValue()      { return value; }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        public final String toString() { return key + &quot;=&quot; + value; }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        public final int hashCode() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return Objects.hashCode(key) ^ Objects.hashCode(value);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        public final V setValue(V newValue) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            V oldValue = value;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            value = newValue;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return oldValue;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        public final boolean equals(Object o) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (o == this)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                return true;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (o instanceof Map.Entry) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (Objects.equals(key, e.getKey()) &amp;&amp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    Objects.equals(value, e.getValue()))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    return true;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return false;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 构造函数 指定初始大小和负载因子</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public HashMap(int initialCapacity, float loadFactor) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (initialCapacity &lt; 0)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                               initialCapacity);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            initialCapacity = MAXIMUM_CAPACITY;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                               loadFactor);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        this.loadFactor = loadFactor;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 计算临界值</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        this.threshold = tableSizeFor(initialCapacity);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public HashMap(int initialCapacity) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        this(initialCapacity, DEFAULT_LOAD_FACTOR);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public HashMap() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public HashMap(Map&lt;? extends K, ? extends V&gt; m) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        this.loadFactor = DEFAULT_LOAD_FACTOR;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        putMapEntries(m, false);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final int tableSizeFor(int cap) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int n = -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 添加值</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public V put(K key, V value) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 计算key的hash值</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return putVal(hash(key), key, value, false, true);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;K,V&gt;[] tab;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;K,V&gt; p; // hash 指向的节点</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int n, i; // n 是容器数组长度</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 如果table为空或者长度为0 则扩容</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if ((tab = table) == null || (n = tab.length) == 0)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            n = (tab = resize()).length;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // tab 当前位置为空，直接插入（多线程下容易数据被覆盖）</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            tab[i] = newNode(hash, key, value, null);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        else {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // hash 冲突</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Node&lt;K,V&gt; e; K k;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // key 相同</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                e = p;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // key 不同且是使用红黑树处理冲突</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            else if (p instanceof TreeNode)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            else {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 使用链表处理冲突</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 遍历链表</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                for (int binCount = 0; ; ++binCount) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    // 链表的尾端也没有找到key值相同的节点，则生成一个新的Node</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if ((e = p.next) == null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        p.next = newNode(hash, key, value, null);</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        // 是否树化</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            treeifyBin(tab, hash);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        break;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    // 找到相同的 key</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        break;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    p = e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (e != null) { // existing mapping for key</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 替换旧的值</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                V oldValue = e.value;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (!onlyIfAbsent || oldValue == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    e.value = value;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                afterNodeAccess(e);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                return oldValue;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 修改次数</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        ++modCount;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 实际容量大于临界值 扩容</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (++size &gt; threshold)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            resize();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        afterNodeInsertion(evict);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 扩容并复制数据</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    final Node&lt;K,V&gt;[] resize() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;K,V&gt;[] oldTab = table;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int oldCap = (oldTab == null) ? 0 : oldTab.length;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int oldThr = threshold;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int newCap, newThr = 0;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 容器实际容量大于0</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (oldCap &gt; 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">             // 判断当前Node的长度，如果当前长度超过 MAXIMUM_CAPACITY（最大容量值）</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (oldCap &gt;= MAXIMUM_CAPACITY) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 新增阀值为 Integer.MAX_VALUE</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                threshold = Integer.MAX_VALUE;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                return oldTab;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 如果小于这个 MAXIMUM_CAPACITY（最大容量值），并且大于 DEFAULT_INITIAL_CAPACITY （默认16）</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 2倍扩容</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                newThr = oldThr &lt;&lt; 1; // double threshold</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        else if (oldThr &gt; 0) // initial capacity was placed in threshold</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 指定新增阀值</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            newCap = oldThr;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        else {               // zero initial threshold signifies using defaults</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 如果数组为空</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            //使用默认的加载因子(0.75)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            newCap = DEFAULT_INITIAL_CAPACITY;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">             // 新增的阀值也就为 16 * 0.75 = 12</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (newThr == 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 按照给定的初始大小计算扩容后的新增阀值</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            float ft = (float)newCap * loadFactor;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                      (int)ft : Integer.MAX_VALUE);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 扩容后的新增阀值</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        threshold = newThr;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 扩容后的Node数组</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        table = newTab;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         // 如果数组不为空，将原数组中的元素放入扩容后的数组中</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (oldTab != null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            for (int j = 0; j &lt; oldCap; ++j) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                Node&lt;K,V&gt; e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if ((e = oldTab[j]) != null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    oldTab[j] = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    // 如果节点为空，则直接计算在新数组中的位置，放入即可</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if (e.next == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        newTab[e.hash &amp; (newCap - 1)] = e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    else if (e instanceof TreeNode)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        // 拆分树节点</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    else { // preserve order</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        // 如果节点不为空，且为单链表，则将原数组中单链表元素进行拆分</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        Node&lt;K,V&gt; loHead = null, loTail = null; // 保存在原有索引的链表</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        Node&lt;K,V&gt; hiHead = null, hiTail = null; // 保存在新索引的链表</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        Node&lt;K,V&gt; next;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        do {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            next = e.next;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            // 哈希值和原数组长度进行&amp;操作，为0则在原数组的索引位置</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            // 非0则在原数组索引位置+原数组长度的新位置</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            if ((e.hash &amp; oldCap) == 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                if (loTail == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    loHead = e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                else</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    loTail.next = e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                loTail = e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            else {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                if (hiTail == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    hiHead = e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                else</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    hiTail.next = e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                hiTail = e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        } while ((e = next) != null);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        if (loTail != null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            loTail.next = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            newTab[j] = loHead;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        if (hiTail != null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            hiTail.next = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            newTab[j + oldCap] = hiHead;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return newTab;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 创建新的节点</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return new Node&lt;&gt;(hash, key, value, next);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // hash函数</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // (1) 取key的hashCode值，h = key.hashCode()； </span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // (2) 高位参与运算，h ^ (h &gt;&gt;&gt; 16)； </span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // (3) 取模运算，h &amp; (length-1)。</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final int hash(Object key) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int h;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 红黑树结构实现 简略部分代码</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        TreeNode&lt;K,V&gt; parent;  // red-black tree links</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        TreeNode&lt;K,V&gt; left;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        TreeNode&lt;K,V&gt; right;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        boolean red;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            super(hash, key, val, next);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 把放入红黑树中</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                       int h, K k, V v) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Class&lt;?&gt; kc = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            boolean searched = false;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            for (TreeNode&lt;K,V&gt; p = root;;) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                int dir, ph; K pk;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if ((ph = p.hash) &gt; h)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    dir = -1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                else if (ph &lt; h)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    dir = 1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    return p;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                else if ((kc == null &amp;&amp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                          (kc = comparableClassFor(k)) == null) ||</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                         (dir = compareComparables(kc, k, pk)) == 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if (!searched) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        TreeNode&lt;K,V&gt; q, ch;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        searched = true;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        if (((ch = p.left) != null &amp;&amp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                             (q = ch.find(h, k, kc)) != null) ||</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            ((ch = p.right) != null &amp;&amp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                             (q = ch.find(h, k, kc)) != null))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            return q;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    dir = tieBreakOrder(k, pk);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                TreeNode&lt;K,V&gt; xp = p;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    Node&lt;K,V&gt; xpn = xp.next;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if (dir &lt;= 0)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        xp.left = x;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    else</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        xp.right = x;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    xp.next = x;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    x.parent = x.prev = xp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if (xpn != null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    moveRootToFront(tab, balanceInsertion(root, x));</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    return null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return ((parent != null) ? root() : this).find(h, k, null);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 查找红黑树</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            TreeNode&lt;K,V&gt; p = this;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            do {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                int ph, dir; K pk;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if ((ph = p.hash) &gt; h)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    p = pl;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                else if (ph &lt; h)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    p = pr;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    return p;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                else if (pl == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    p = pr;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                else if (pr == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    p = pl;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                else if ((kc != null ||</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                          (kc = comparableClassFor(k)) != null) &amp;&amp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                         (dir = compareComparables(kc, k, pk)) != 0)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    p = (dir &lt; 0) ? pl : pr;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                else if ((q = pr.find(h, k, kc)) != null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    return q;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                else</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    p = pl;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            } while (p != null);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 获取值</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public V get(Object key) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;K,V&gt; e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return (e = getNode(hash(key), key)) == null ? null : e.value;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    final Node&lt;K,V&gt; getNode(int hash, Object key) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;K,V&gt;[] tab; </span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;K,V&gt; first, e; </span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int n; </span></div><div class="token-line" style="color:#393A34"><span class="token plain">        K k;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // table不为空且长度大于0且值存在</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 先检查头结点</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (first.hash == hash &amp;&amp;  ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                return first;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 遍历</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if ((e = first.next) != null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 遍历红黑数</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (first instanceof TreeNode)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                do {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    // 遍历链表</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        return e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                } while ((e = e.next) != null);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 数化</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int n, index; </span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;K,V&gt; e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        </span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 容器小于 MIN_TREEIFY_CAPACITY 扩容</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            resize();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        else if ((e = tab[index = (n - 1) &amp; hash]) != null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 树化操作</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            TreeNode&lt;K,V&gt; hd = null, tl = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            do {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (tl == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    hd = p;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                else {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    p.prev = tl;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    tl.next = p;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                tl = p;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            } while ((e = e.next) != null);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if ((tab[index] = hd) != null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                hd.treeify(tab);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="hash"></a>hash<a class="hash-link" href="#hash" title="Direct link to heading">#</a></h3><p><code>tab[i = (n - 1) &amp; hash]</code> 用来定位桶位置</p><p><code>(n - 1) &amp; hash</code> 位运算得到的值小于 (n-1)</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="为什么会hash冲突"></a>为什么会hash冲突<a class="hash-link" href="#为什么会hash冲突" title="Direct link to heading">#</a></h3><p>就是根据key即经过一个函数f(key)得到的结果的作为地址去存放当前的key，value键值对(这个是hashmap的存值方式)，但是却发现算出来的地址上已经有数据。</p><p>hash冲突的几种情况:</p><ul><li>两个节点的key值相同（hash值一定相同），导致冲突 </li><li>两个节点的key值不同，由于hash函数的局限性导致hash值相同，导致冲突 </li><li>两个节点的key值不同，hash值不同，但hash值对数组长度取模后相同，导致冲突 </li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="解决hash冲突"></a>解决hash冲突<a class="hash-link" href="#解决hash冲突" title="Direct link to heading">#</a></h4><ol><li>开放寻址法--线性探测</li></ol><p>当一个Key通过hash函数获得对应的数组下标已被占用的时候，就可以寻找下一个空档位置</p><ol start="2"><li>链表法</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="线程不安全的表现"></a>线程不安全的表现<a class="hash-link" href="#线程不安全的表现" title="Direct link to heading">#</a></h3><p>在JDK1.8中，在并发执行put操作时会发生数据覆盖的情况</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">if ((p = tab[i = (n - 1) &amp; hash]) == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        tab[i] = newNode(hash, key, value, null);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>发生场景:</p><ol><li>假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的</li><li>当线程A执行完上面代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入</li><li>然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，</li></ol><p>这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="linkedhashmapclass"></a>LinkedHashMap.class<a class="hash-link" href="#linkedhashmapclass" title="Direct link to heading">#</a></h2><ul><li>LinkedHashMap是继承于HashMap，是基于HashMap和双向链表来实现的。</li><li>HashMap无序；LinkedHashMap有序，可分为插入顺序（先进先出）和访问顺序（最近最少）两种。<br>如果是访问顺序，那put和get操作已存在的Entry时，都会把Entry移动到双向链表的表尾(其实是先删除再插入)。</li><li>LinkedHashMap存取数据，还是跟HashMap一样使用的Entry[]的方式，双向链表只是为了保证顺序。</li><li>LinkedHashMap是线程不安全的。</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="架构图-1"></a>架构图<a class="hash-link" href="#架构图-1" title="Direct link to heading">#</a></h3><p><img src="/docs.advanced.way/assets/images/LinkedHashMap-8ea2d47f5cfbbe121ff1c963cc4f163b.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="源码-1"></a>源码<a class="hash-link" href="#源码-1" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public class LinkedHashMap&lt;K,V&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    extends HashMap&lt;K,V&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    implements Map&lt;K,V&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">{</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    transient LinkedHashMap.Entry&lt;K,V&gt; head;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 表示迭代顺序，true表示访问顺序，false表示插入顺序</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    final boolean accessOrder;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="put-方法"></a>put 方法<a class="hash-link" href="#put-方法" title="Direct link to heading">#</a></h4><p>LinkedHashMap 没有重写put方法，所以还是调用HashMap得到put方法</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// HashMap.class</span></div><div class="token-line" style="color:#393A34"><span class="token plain">public V put(K key, V value) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    return putVal(hash(key), key, value, false, true);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                boolean evict) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    ...</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    afterNodeInsertion(evict);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    return null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">void afterNodeInsertion(boolean evict) { }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// LinkedHashMap.class</span></div><div class="token-line" style="color:#393A34"><span class="token plain">void afterNodeInsertion(boolean evict) { // possibly remove eldest</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    LinkedHashMap.Entry&lt;K,V&gt; first;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        K key = first.key;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        removeNode(hash(key), key, null, false, true);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    return false;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="参考内容"></a>参考内容<a class="hash-link" href="#参考内容" title="Direct link to heading">#</a></h2><p><a href="https://www.cnblogs.com/myseries/p/10876828.html" target="_blank" rel="noopener noreferrer">Java8 HashMap详解</a></p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Goldwood1024/docs.advanced.way/tree/master/docs/java/collection/Map.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-07-06T06:05:23.000Z" class="lastUpdatedDate_1WI_">7/6/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs.advanced.way/docs/java/collection/List"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« List</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs.advanced.way/docs/java/hc/高并发"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">高并发 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#mapclass" class="table-of-contents__link">Map.class</a><ul><li><a href="#嵌套接口" class="table-of-contents__link">嵌套接口</a></li></ul></li><li><a href="#hashmapclass" class="table-of-contents__link">HashMap.class</a><ul><li><a href="#架构图" class="table-of-contents__link">架构图</a></li><li><a href="#数据结构" class="table-of-contents__link">数据结构</a></li><li><a href="#源码" class="table-of-contents__link">源码</a></li><li><a href="#hash" class="table-of-contents__link">hash</a></li><li><a href="#为什么会hash冲突" class="table-of-contents__link">为什么会hash冲突</a></li><li><a href="#线程不安全的表现" class="table-of-contents__link">线程不安全的表现</a></li></ul></li><li><a href="#linkedhashmapclass" class="table-of-contents__link">LinkedHashMap.class</a><ul><li><a href="#架构图-1" class="table-of-contents__link">架构图</a></li><li><a href="#源码-1" class="table-of-contents__link">源码</a></li></ul></li><li><a href="#参考内容" class="table-of-contents__link">参考内容</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 进阶之路, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/docs.advanced.way/assets/js/runtime~main.aa1c8b94.js"></script>
<script src="/docs.advanced.way/assets/js/main.8fae9188.js"></script>
</body>
</html>