<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.75">
<link rel="alternate" type="application/rss+xml" href="/docs.advanced.way/blog/rss.xml" title="进阶之路 Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/docs.advanced.way/blog/atom.xml" title="进阶之路 Blog Atom Feed"><title data-react-helmet="true">多线程 | 进阶之路</title><meta data-react-helmet="true" property="og:url" content="https://Goldwood1024.github.io/docs.advanced.way/docs/java/hc/多线程"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="多线程 | 进阶之路"><meta data-react-helmet="true" name="description" content="线程"><meta data-react-helmet="true" property="og:description" content="线程"><link data-react-helmet="true" rel="shortcut icon" href="/docs.advanced.way/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Goldwood1024.github.io/docs.advanced.way/docs/java/hc/多线程"><link data-react-helmet="true" rel="alternate" href="https://Goldwood1024.github.io/docs.advanced.way/docs/java/hc/多线程" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Goldwood1024.github.io/docs.advanced.way/docs/java/hc/多线程" hreflang="x-default"><link rel="stylesheet" href="/docs.advanced.way/assets/css/styles.5e159b62.css">
<link rel="preload" href="/docs.advanced.way/assets/js/runtime~main.aa1c8b94.js" as="script">
<link rel="preload" href="/docs.advanced.way/assets/js/main.8fae9188.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top navbarHideable_2qcr"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/docs.advanced.way/"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">进阶之路</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs.advanced.way/docs/java/">Java</a><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link">生态</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/spring-family/">Spring家族</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/framework/mybatis/">常用框架</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/distributed/">分布式</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/cloud/docker/base/镜像/">容器</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/db/mysql/InnoDB/">数据库</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/os/network/tcpip/">计算机系统</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link">编码实践</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs.advanced.way/docs/algorithm/algorithm/">算法/数据结构</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/patterns/">设计模式</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/architecture/">系统架构</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/practice/memo/tool/sublime/">备忘录</a></li></ul></div></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/docs.advanced.way/blog">博客</a><a href="https://github.com/Goldwood1024/docs.advanced.way.git" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/docs.advanced.way/"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">进阶之路</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs.advanced.way/docs/java/">Java</a></li><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist">生态</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/spring-family/">Spring家族</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/framework/mybatis/">常用框架</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/distributed/">分布式</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/cloud/docker/base/镜像/">容器</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/db/mysql/InnoDB/">数据库</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/os/network/tcpip/">计算机系统</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist">编码实践</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/algorithm/algorithm/">算法/数据结构</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/patterns/">设计模式</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/architecture/">系统架构</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/practice/memo/tool/sublime/">备忘录</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/blog">博客</a></li><li class="menu__list-item"><a href="https://github.com/Goldwood1024/docs.advanced.way.git" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo sidebarWithHideableNavbar_267A"><a tabindex="-1" class="sidebarLogo_3h0W" href="/docs.advanced.way/"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--dark_hz6m"><strong>进阶之路</strong></a><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">基础</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/">简介</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/object">面向对象</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/数据类型">数据类型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/关键字">关键字</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/String">String</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/io">I/O</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/nio">NIO</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/Reference">对象引用</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/代理">代理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/函数式接口">函数式接口</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/反射">反射</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/base64">Base64编码</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/jdk">JDK</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">集合</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/collection/Collection">Collection</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/collection/List">List</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/collection/Map">Map</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">高并发</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/高并发">高并发</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs.advanced.way/docs/java/hc/多线程">多线程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/并发编程的艺术">并发编程的艺术</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/内存模型">内存模型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/原子类">原子类</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/并发容器">并发容器</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/并发工具类">并发工具类</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/线程池">线程池</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/锁">锁</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">JVM</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/对象创建过程">对象创建过程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/对象回收机制">对象回收机制</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/jvm参数">JVM参数</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/jvm内存模型">内存模型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/内存优化">内存优化</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/垃圾收集器">垃圾收集器</a></li></ul></li></ul></div><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_1CGd"><svg width="20" height="20" role="img" class="collapseSidebarButtonIcon_3E-R"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">多线程</h1></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="线程"></a>线程<a class="hash-link" href="#线程" title="Direct link to heading">#</a></h2><p>现代操作系统在运行一个程序时，会创建一个进程。操作系统调度最小的单元是线程。
一个进程内可以创建多个线程，这些线程又有各自的计数器，堆栈和局部变量</p><p>优点:</p><ul><li>更多的处理器核心</li><li>更快的响应时间</li><li>更好的编程模型</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="并发和并行"></a>并发和并行<a class="hash-link" href="#并发和并行" title="Direct link to heading">#</a></h3><p>多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销</p><ul><li>并行是指同一时刻，多个命令在多个处理器上同时执行；</li><li>并发是指在同一时刻，只有一条命令是在处理器上执行的，但多个进程命令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="线程状态"></a>线程状态<a class="hash-link" href="#线程状态" title="Direct link to heading">#</a></h3><p><img src="/docs.advanced.way/assets/images/1689841-af3e5b75b44e972c-466ad979fe759b0ca16be0b465eda842.png"></p><p><img src="/docs.advanced.way/assets/images/1689841-383f7101e6588094-eeb862b5be48478843f674863e74339d.png"></p><ol><li><p>新建状态:<br>
使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。</p></li><li><p>就绪状态:<br>
当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。  </p><blockquote><p>每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列，就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程，当一个被线程被唤醒 (notify)后，才会进入到就绪队列，等待获得锁  </p></blockquote></li><li><p>运行状态:<br>
如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p></li><li><p>阻塞状态:<br>
如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。<br>
可以分为三种：
等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。<br>
同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。<br>
其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。  </p></li></ol><ul><li>调用join()和sleep()方法，sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态，等待JVM的调度。</li><li>调用wait()，使该线程处于等待池(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到锁定池(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable）</li><li>对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。</li></ul><ol start="5"><li>死亡状态:
一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。  </li></ol><blockquote><p>start()的含义: 当前线程同步告知虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程
join()的含义: 当前线程等待thread线程终止之后才从thread.join()返回</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="创建线程"></a>创建线程<a class="hash-link" href="#创建线程" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="创建"></a>创建<a class="hash-link" href="#创建" title="Direct link to heading">#</a></h4><ol><li>继承Thread类</li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">class Thread1 extends Thread {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // to do</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ol start="2"><li>实现 Runnable</li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">class class2 implements Runnable{</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ol start="3"><li>实现 Callable</li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">class class3 implements Callable&lt;String&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public String call() throws Exception {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="原理"></a>原理<a class="hash-link" href="#原理" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">// 接受泛型参数</span></div><div class="token-line" style="color:#393A34"><span class="token plain">@FunctionalInterface</span></div><div class="token-line" style="color:#393A34"><span class="token plain">public interface Callable&lt;V&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    V call() throws Exception;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">@FunctionalInterface</span></div><div class="token-line" style="color:#393A34"><span class="token plain">public interface Runnable {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public abstract void run();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// 实现 Runnable</span></div><div class="token-line" style="color:#393A34"><span class="token plain">public class Thread implements Runnable {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>Runnable没有返回值；Callable可以返回执行结果，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</p><h5><a aria-hidden="true" tabindex="-1" class="anchor" id="future"></a>Future<a class="hash-link" href="#future" title="Direct link to heading">#</a></h5><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。
必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public interface Future&lt;V&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    boolean cancel(boolean mayInterruptIfRunning);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 判断任务是否被取消成功</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    boolean isCancelled();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 判断任务是否已经完成</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    boolean isDone();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    V get() throws InterruptedException, ExecutionException;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h5><a aria-hidden="true" tabindex="-1" class="anchor" id="runnablefutureclass"></a>RunnableFuture.class<a class="hash-link" href="#runnablefutureclass" title="Direct link to heading">#</a></h5><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    void run();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h5><a aria-hidden="true" tabindex="-1" class="anchor" id="futuretaskclass"></a>FutureTask.class<a class="hash-link" href="#futuretaskclass" title="Direct link to heading">#</a></h5><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private volatile int state;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final int NEW          = 0;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final int COMPLETING   = 1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final int NORMAL       = 2;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final int EXCEPTIONAL  = 3;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final int CANCELLED    = 4;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final int INTERRUPTING = 5;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final int INTERRUPTED  = 6;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    /** The underlying callable; nulled out after running */</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private Callable&lt;V&gt; callable;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    /** The result to return or exception to throw from get() */</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private Object outcome; // non-volatile, protected by state reads/writes</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    /** The thread running the callable; CASed during run() */</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private volatile Thread runner;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    /** Treiber stack of waiting threads */</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private volatile WaitNode waiters;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public FutureTask(Callable&lt;V&gt; callable) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (callable == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            throw new NullPointerException();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        this.callable = callable;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        this.state = NEW;       // ensure visibility of callable</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (state != NEW ||</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            !RUNNER.compareAndSet(this, null, Thread.currentThread()))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        try {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Callable&lt;V&gt; c = callable;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (c != null &amp;&amp; state == NEW) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                V result;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                boolean ran;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                try {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    // 执行任务</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    result = c.call();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    ran = true;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                } catch (Throwable ex) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    result = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    ran = false;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    setException(ex);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (ran)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    // 设置值</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    set(result);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // runner must be non-null until state is settled to</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // prevent concurrent calls to run()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            runner = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // state must be re-read after nulling runner to prevent</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // leaked interrupts</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            int s = state;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (s &gt;= INTERRUPTING)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                handlePossibleCancellationInterrupt(s);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    protected void set(V v) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (STATE.compareAndSet(this, NEW, COMPLETING)) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            outcome = v;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            STATE.setRelease(this, NORMAL); // final state</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            finishCompletion();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private void finishCompletion() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // assert state &gt; COMPLETING;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        for (WaitNode q; (q = waiters) != null;) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (WAITERS.weakCompareAndSet(this, q, null)) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                for (;;) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    Thread t = q.thread;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if (t != null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        q.thread = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        LockSupport.unpark(t);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    WaitNode next = q.next;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if (next == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        break;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    q.next = null; // unlink to help gc</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    q = next;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                break;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        done();</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        callable = null;        // to reduce footprint</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    protected void done() { }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="线程管理"></a>线程管理<a class="hash-link" href="#线程管理" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="睡眠"></a>睡眠<a class="hash-link" href="#睡眠" title="Direct link to heading">#</a></h4><p>让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用Thread的sleep方法</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Thread.sleep(1000*1); // 休眠1秒</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="线程让步yield"></a>线程让步——yield<a class="hash-link" href="#线程让步yield" title="Direct link to heading">#</a></h4><p>yield()方法只是让当前线程暂停一下，重新进入就绪的线程池中，让系统的线程调度器重新调度器重新调度一次（不进入阻塞状态）</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="线程合并"></a>线程合并<a class="hash-link" href="#线程合并" title="Direct link to heading">#</a></h4><p>线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能执行时，Thread类提供了join方法来完成这个功能，注意，它不是静态方法</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="线程的优先级"></a>线程的优先级<a class="hash-link" href="#线程的优先级" title="Direct link to heading">#</a></h4><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。<br>
Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。<br>
默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="线程调度"></a>线程调度<a class="hash-link" href="#线程调度" title="Direct link to heading">#</a></h3><p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式分两种，分别是协同式线程调度和抢占式线程调度。   </p><ul><li>协同式线程调度<br>线程执行时间由线程本身来控制，线程把自己的工作执行完之后，要主动通知系统切换到另外一个线程上。最大好处是实现简单，且切换操作对线程自己是可知的，没啥线程同步问题。坏处是线程执行时间不可控制，如果一个线程有问题，可能一直阻塞在那里。 </li><li>抢占式调度<br>每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（Java中，Thread.yield()可以让出执行时间，但无法获取执行时间）。线程执行时间系统可控，也不会有一个线程导致整个进程阻塞。  </li></ul><blockquote><p>Java线程调度就是抢占式调度。 </p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="线程同步"></a>线程同步<a class="hash-link" href="#线程同步" title="Direct link to heading">#</a></h3><p> java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="同步方法"></a>同步方法<a class="hash-link" href="#同步方法" title="Direct link to heading">#</a></h4><blockquote><p>由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态</p></blockquote><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">// 对象锁</span></div><div class="token-line" style="color:#393A34"><span class="token plain">public synchronized void fun(){</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // todo</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// 类锁</span></div><div class="token-line" style="color:#393A34"><span class="token plain">public synchronized static void fun(){</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // todo</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ol><li><p>内置锁（又叫 隐式锁）：synchronized 是内置于JDK中的，底层实现是native；同时，加锁、解锁都是JDK自动完成，不需要用户显式地控制，非常方便。</p></li><li><p>同步锁：synchronized 用于同步线程，使线程互斥地访问某段代码块、方法。这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去</p></li><li><p>对象锁：准确来说，是分为对象锁、类锁。synchronized 以当前的某个对象为锁，线程必须通过互斥竞争拿到这把对象锁，从而才能访问 临界区的代码，访问结束后，就会释放锁，下一个线程才有可能获取锁来访问临界区（被锁住的代码区域）。</p><blockquote><p>synchronized锁 根据锁的范围分为 对象锁 和 类锁。<br>
对象锁，是以对象实例为锁，当多个线程共享访问这个对象实例下的临界区，只需要竞争这个对象实例便可，不同对象实例下的临界区是不用互斥访问；<br>
类锁，则是以类的class对象为锁，这个锁下的临界区，所有线程都必须互斥访问，尽管是使用了不同的对象实例</p></blockquote><blockquote><p>临界区就是在同一时刻只能有一个任务访问的代码区</p></blockquote></li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="同步代码块"></a>同步代码块<a class="hash-link" href="#同步代码块" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public int fun(){</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    synchronized( object ) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">       //代码块，一次只能有一个线程进入</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ol><li><p>object 是 this，是对象锁，this指代当前对象</p></li><li><p>object 是一个普通对象实例  </p><blockquote><p>如果是静态对象，那么就是 类锁；<br>
如果是非静态对象：成员对象变量、局部变量（甚至可以是 方法参数），那么就是对象锁</p></blockquote></li><li><p>object 是一个类的class 对象，那么就是类锁</p></li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="volatile"></a>volatile<a class="hash-link" href="#volatile" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">private volatile int account = 100;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>volatile关键字为域变量的访问提供了一种免锁机制；</li><li>使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新；</li><li>因此每次使用该域就要重新计算，而不是使用寄存器中的值；</li><li>volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="重入锁（lock）"></a>重入锁（Lock）<a class="hash-link" href="#重入锁（lock）" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">ReentrantLock() : 创建一个ReentrantLock实例         </span></div><div class="token-line" style="color:#393A34"><span class="token plain">lock() : 获得锁        </span></div><div class="token-line" style="color:#393A34"><span class="token plain">unlock() : 释放锁</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h5><a aria-hidden="true" tabindex="-1" class="anchor" id="公平锁非公平锁（多线程执行顺序的维度）"></a>公平锁/非公平锁（多线程执行顺序的维度）<a class="hash-link" href="#公平锁非公平锁（多线程执行顺序的维度）" title="Direct link to heading">#</a></h5><ul><li>公平锁：加锁前先查看是否有排队等待的线程，有的话优先处理排在前面的线程，先来先得。</li><li>非公平所：线程加锁时直接尝试获取锁，获取不到就自动到队尾等待。</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">//创建一个非公平锁，默认是非公平锁</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Lock nonFairLock= new ReentrantLock();</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Lock nonFairLock= new ReentrantLock(false);</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">//创建一个公平锁，构造传参true</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Lock fairLock= new ReentrantLock(true);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h5><a aria-hidden="true" tabindex="-1" class="anchor" id="乐观锁悲观锁（多线程操作共享数据的维度）"></a>乐观锁/悲观锁（多线程操作共享数据的维度）<a class="hash-link" href="#乐观锁悲观锁（多线程操作共享数据的维度）" title="Direct link to heading">#</a></h5><ul><li>悲观锁：假设一定会发生并发冲突，通过阻塞其他所有线程来保证数据的完整性。</li><li>乐观锁：假设不会发生并发冲突，直接不加锁去完成某项更新，如果冲突就返回失败。</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="线程通信"></a>线程通信<a class="hash-link" href="#线程通信" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="object类的-wait、notify、notifyall"></a>Object类的 wait()、notify()、notifyAll()<a class="hash-link" href="#object类的-wait、notify、notifyall" title="Direct link to heading">#</a></h4><ul><li>线程执行wait()后，就放弃了运行资格，处于冻结状态；</li><li>线程运行时，内存中会建立一个线程池，冻结状态的线程都存在于线程池中，notify()执行时唤醒的也是线程池中的线程，线程池中有多个线程时唤醒第一个被冻结的线程。</li><li>notifyall(), 唤醒线程池中所有线程。</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="condition控制线程通信"></a>Condition控制线程通信<a class="hash-link" href="#condition控制线程通信" title="Direct link to heading">#</a></h4><ul><li>将同步synchronized替换为显式的Lock操作；</li><li>将Object类中的wait(), notify(),notifyAll()替换成了Condition对象，该对象可以通过Lock锁对象获取;</li><li>一个Lock对象上可以绑定多个Condition对象，这样实现了本方线程只唤醒对方线程，而jdk1.5之前，一个同步只能有一个锁，不同的同步只能用锁来区分，且锁嵌套时容易死锁。</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="阻塞队列（blockingqueue）控制线程通信"></a>阻塞队列（BlockingQueue）控制线程通信<a class="hash-link" href="#阻塞队列（blockingqueue）控制线程通信" title="Direct link to heading">#</a></h4><p>BlockingQueue是一个接口，也是Queue的子接口。<br>
BlockingQueue具有一个特征：当生产者线程试图向BlockingQueue中放入元素时，如果该队列已满，则线程被阻塞；但消费者线程试图从BlockingQueue中取出元素时，如果队列已空，则该线程阻塞。程序的两个线程通过交替向BlockingQueue中放入元素、取出元素，即可很好地控制线程的通信。</p><p>BlockingQueue提供如下两个支持阻塞的方法：  </p><p>（1）put(E e)：尝试把Eu元素放如BlockingQueue中，如果该队列的元素已满，则阻塞该线程。<br>
（2）take（）：尝试从BlockingQueue的头部取出元素，如果该队列的元素已空，则阻塞该线程。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">ArrayBlockingQueue ：基于数组实现的BlockingQueue队列。</span></div><div class="token-line" style="color:#393A34"><span class="token plain">LinkedBlockingQueue：基于链表实现的BlockingQueue队列。</span></div><div class="token-line" style="color:#393A34"><span class="token plain">PriorityBlockingQueue：它并不是保准的阻塞队列，该队列调用remove（）、poll（）、take（）等方法提取出元素时，并不是取出队列中存在时间最长的元素，而是队列中最小的元素。</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                       它判断元素的大小即可根据元素（实现Comparable接口）的本身大小来自然排序，也可使用Comparator进行定制排序。</span></div><div class="token-line" style="color:#393A34"><span class="token plain">SynchronousQueue：同步队列。对该队列的存、取操作必须交替进行。</span></div><div class="token-line" style="color:#393A34"><span class="token plain">DelayQueue：它是一个特殊的BlockingQueue，底层基于PriorityBlockingQueue实现，不过，DelayQueue要求集合元素都实现Delay接口（该接口里只有一个long getDelay（）方法），</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            DelayQueue根据集合元素的getDalay（）方法的返回值进行排序。</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="threadlocal"></a>ThreadLocal<a class="hash-link" href="#threadlocal" title="Direct link to heading">#</a></h4><p>提供线程本地变量，如果创建一个 <code>ThreadLocal</code> 变量，那么访问这个变量的每个线程都会有这个变量的一个副本，
在实际多线程操作的时候，操作的是自己本地内存中的变量，从而规避了线程安全问题</p><p><img src="/docs.advanced.way/assets/images/1368768-20190614000329689-872917045-d0034fb95f26d81b837b1f8d2f1ad934.png"></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public class ThreadLocal&lt;T&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private final int threadLocalHashCode = nextHashCode();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final int HASH_INCREMENT = 0x61c88647;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static AtomicInteger nextHashCode = new AtomicInteger();</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static int nextHashCode() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return nextHashCode.getAndAdd(HASH_INCREMENT);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // </span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static class ThreadLocalMap {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Object value;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Entry(ThreadLocal&lt;?&gt; k, Object v) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                super(k);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                value = v;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        private static final int INITIAL_CAPACITY = 16;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        private Entry[] table;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        private int size = 0;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        private int threshold;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            table = new Entry[INITIAL_CAPACITY];</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 创建节点并赋值</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            table[i] = new Entry(firstKey, firstValue);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            size = 1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            setThreshold(INITIAL_CAPACITY);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        private Entry getEntry(ThreadLocal&lt;?&gt; key) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            int i = key.threadLocalHashCode &amp; (table.length - 1);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Entry e = table[i];</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (e != null &amp;&amp; e.get() == key)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                return e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            else</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                return getEntryAfterMiss(key, i, e);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        private void set(ThreadLocal&lt;?&gt; key, Object value) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // We don&#x27;t use a fast path as with get() because it is at</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // least as common to use set() to create new entries as</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // it is to replace existing ones, in which case, a fast</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // path would fail more often than not.</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Entry[] tab = table;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            int len = tab.length;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            int i = key.threadLocalHashCode &amp; (len-1);</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            for (Entry e = tab[i];</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                 e != null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                 e = tab[i = nextIndex(i, len)]) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                ThreadLocal&lt;?&gt; k = e.get();</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (k == key) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    e.value = value;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    return;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (k == null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    replaceStaleEntry(key, value, i);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    return;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            tab[i] = new Entry(key, value);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            int sz = ++size;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                rehash();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 扩容</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        private void resize() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Entry[] oldTab = table;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            int oldLen = oldTab.length;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            int newLen = oldLen * 2;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Entry[] newTab = new Entry[newLen];</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            int count = 0;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            for (Entry e : oldTab) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (e != null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    ThreadLocal&lt;?&gt; k = e.get();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if (k == null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        e.value = null; // Help the GC</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    } else {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        int h = k.threadLocalHashCode &amp; (newLen - 1);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        while (newTab[h] != null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            h = nextIndex(h, newLen);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        newTab[h] = e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        count++;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            setThreshold(newLen);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            size = count;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            table = newTab;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 创建实例</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public ThreadLocal() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    ThreadLocalMap getMap(Thread t) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return t.threadLocals;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public void set(T value) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Thread t = Thread.currentThread();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 获取线程 threadLocals</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        ThreadLocalMap map = getMap(t);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (map != null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 设置值</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            map.set(this, value);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        } else {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            createMap(t, value);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 创建一个 ThreadLocalMap</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    void createMap(Thread t, T firstValue) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        t.threadLocals = new ThreadLocalMap(this, firstValue);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 获取值</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public T get() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Thread t = Thread.currentThread();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        ThreadLocalMap map = getMap(t);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (map != null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 获取实体元素</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            ThreadLocalMap.Entry e = map.getEntry(this);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (e != null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                @SuppressWarnings(&quot;unchecked&quot;)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 获取值</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                T result = (T)e.value;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                return result;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return setInitialValue();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 移除</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public void remove() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         ThreadLocalMap m = getMap(Thread.currentThread());</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         if (m != null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">             m.remove(this);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">     }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="线程池"></a>线程池<a class="hash-link" href="#线程池" title="Direct link to heading">#</a></h2><p>在使用线程池之后，创建线程变成了从线程池获得空闲线程，关闭线程变成了向线程池归还线程。<br>
好处:  </p><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="内置线程池"></a>内置线程池<a class="hash-link" href="#内置线程池" title="Direct link to heading">#</a></h3><p>DK并发包中提供了一套Executor线程池框架。Executors类为线程池工厂，通过Executors可以取得一个拥有特定功能的线程池</p><p>Executor线程池框架的最大优点是把任务的提交和执行解耦
<img src="/docs.advanced.way/assets/images/java-7-concurrent-executors-uml-class-diagram-example-5a060fcf244bf15c9a95fb91837c8677.png"></p><p>使用Executors执行多线程任务的步骤如下：</p><p>  • 调用Executors类的静态工厂方法创建一个ExecutorService对象，该对象代表一个线程池；</p><p>  • 创建Runnable实现类或Callable实现类的实例，作为线程执行任务；</p><p>  • 调用ExecutorService对象的submit()方法来提交Runnable实例或Callable实例；</p><p>  • 当不想提交任务时，调用ExecutorService对象的shutdown()方法来关闭线程池</p><p>newFixedThreadPool()：通过该工厂方法返回一个固定线程数量的线程池。线程池中的线程数量始终不变。当没有空闲线程时，新提交的任务则被暂存在一个任务队列中。</p><p>newSingleThreadExecutor()：通过该方法返回一个只有一个线程的线程池。多余的任务被保存在任务队列中，待线程空闲，按先进先出的顺序执行队列中的任务。</p><p>newCachedThreadPool()：通过该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，当所有线程都在工作时，又有新的任务提交，则会创建新的线程来处理任务。所有线程在当前任务执行完毕之后，将返回线程池进行复用。</p><p>newSingleThreadScheduledExecutor()：通过该方法返回一个SheduledExecutorService对象，线程池大小为1。SheduledExecutorService接口在ExecutorService接口上扩展了在给定时间执行某任务的功能，如在某个固定时延之后执行，或者周期性执行某个任务。</p><p>newScheduledThreadPool()：通过该方法返回一个SheduledExecutorService的对象，但该线程池可以指定线程数量</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="线程池参数"></a>线程池参数<a class="hash-link" href="#线程池参数" title="Direct link to heading">#</a></h3><p>内部实现均使用了ThreadPoolExecutor实现，都是通过ThreadPoolExecutor类进行封装之后得到的，实际上就是在ThreadPoolExecutor构造函数中指定不同的参数来构造不同的线程池</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public ThreadPoolExecutor(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            int corePoolSize,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            int maxnumPoolSize,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            long keepAliveTime,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            TimeUnit unit,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            BlockingQueue&lt;Runnable&gt; workQueue,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            ThreadFactory threadFactory,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            RejectedExecutionHandler handler</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            )</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>corePoolSize:指定了线程池中的线程数量。</li><li>maxnumPoolSize:指定了线程池中的最大线程数量。</li><li>keepAliveTime:当线程池线程数量超过corePoolSize时，多余的空闲线程的存活时间，即超过corePoolSize的空闲线程在多长的时间内会被销毁。</li><li>unit: keepAliveTime的单位。</li><li>workQueue:任务队列，被提交但尚未被执行的任务。</li><li>threadFactory:线程工厂，用于创建线程，一般用默认的即可。</li><li>handler:拒绝策略，当任务太多来不及处理时拒绝执行的策略。</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="任务队列"></a>任务队列<a class="hash-link" href="#任务队列" title="Direct link to heading">#</a></h4><p>参数任务队列指被提交但是未执行的队列任务，它是一个BlockingQueue接口的对象，用于存放Runnable对象</p><p>(1)	直接提交的队列：该功能由SynchronizedQueue对象提供。SynchronizedQueue是一个特殊的阻塞队列。SynchronizedQueue没有容量，每一个插入操作都要等待一个相应的删除操作，反之每一个删除操作都需要等待对应的插入操作。使用SynchronizedQueue时提交的任务不会被真实的保存，而总是将新任务提交给线程执行，如果没有空闲的线程则尝试创建新的线程，如果线程数量达到最大值就执行决绝策略。使用SynchronizedQueue队列通常要设置很大的maxnumPoolSize，否则很容易执行拒绝策略。可以当做大小为0的队列来理解。</p><p>(2)	有界的任务队列：有界的任务队列可以使用ArrayBlockingQueue实现。当使用有界的任务队列时，若有新的任务需要执行，如果线程池的实际线程数小于核心线程数，则有优先创建新的线程，若大于核心线程数，则会将新任务加入等待队列。若队列已满，无法加入则在总线程数不大于最大线程数的前提下，创建新的线程。若大于最大线程数，则执行拒绝策略。也就是说，有界队列仅当任务队列满时才可能将线程数提升到核心线程数只上，否则确保线程数维持在核心线程数大小。</p><p>(3)	无界任务队列：无界任务队列可以通过LinkedBlockingQueue类来实现。与有界队列相比，除非系统资源耗尽，否则无界队列不存在任务入队失败的情况。当有新的任务到来，系统的线程数小于核心线程数时线程池会生成新的线程执行任务，但当系统线程数大于核心线程数后，就不会继续增加。若后续有新的任务，则将任务放入无界队列中等待。</p><p>(4)	优先任务队列：优先任务队列是带有执行优先级的队列，通过PriorityBlockingQueue实现，可以控制任务的执行先后顺序，是一个特殊的无界队列。无论是有界队列还ArrayBlockingQueue还是未指定大小的无界队列LinkedBlockingQueue，都是按照先进先出算法处理任务的，而有限队列则可以根据任务自身的优先级顺序执行，在确保系统性能的同时，也能有很好的质量保证。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="拒绝策略"></a>拒绝策略<a class="hash-link" href="#拒绝策略" title="Direct link to heading">#</a></h4><p>当线程池中的线程已经用完，无法继续为新任务服务，同时等待队列中已经排满，再也塞不下新任务了</p><ul><li>AbortPolicy：该策略会抛出异常，阻止系统正常工作。</li><li>CallerRunsPolicy：只要线程池未关闭，该策略直接在调用者线程中运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是任务提交线程的性能可能会急剧下降。</li><li>DiscardOledestPolicy：该策略将丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</li><li>DiscardPolicy：该策略默默丢弃无法处理的任务，不予任何处理。在允许任务丢失的情况下这是一种合适的方案。</li></ul><p>以上内置的策略均实现了RejectedExecutionHandler接口，若仍无法满足实际需要，可以自己扩展RejectedExecutionHandler接口，通过复写rejectedExecution方法，来实现自己饿拒绝策略</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public ThreadPoolExecutor(5,5,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                0L,TimeUnit.MICROSECONDS,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                new LinkedBlockingQueue&lt;Runnable&gt;(10),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                Executors.defaultThreadFactory(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                new RejectedExecutionHandler() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    public void rejected(Runnable r, ThreadPoolExecutor executor) {  </span></div><div class="token-line" style="color:#393A34"><span class="token plain">                      System.out.println(r.toString()+&quot;is discard&quot;);                                                          </span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                });</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="线程池扩展"></a>线程池扩展<a class="hash-link" href="#线程池扩展" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">ExecutorService eService = new ThreadPoolExecutor(5,5,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        0L,TimeUnit.MICROSECONDS,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        new LinkedBlockingQueue&lt;Runnable&gt;(10),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Executors.defaultThreadFactory(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        new RejectedExecutionHandler() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(r.toString()+&quot;is discard&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            @Override</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            protected void beforeExecute(Thread thread ,Runnable r){</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;准备执行&quot;+((MyTask)r).name);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            </span></div><div class="token-line" style="color:#393A34"><span class="token plain">            @Override</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            protected void afterExecute(Runnable r,Throwable t){</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;执行完成&quot;+((MyTask)r).name);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">};</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="executorservice有如下几个执行方法"></a>ExecutorService有如下几个执行方法<a class="hash-link" href="#executorservice有如下几个执行方法" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">- execute(Runnable)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">- submit(Runnable)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">- submit(Callable)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">- invokeAny(...)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">- invokeAll(...)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h5><a aria-hidden="true" tabindex="-1" class="anchor" id="submitrunnable"></a>submit(Runnable)<a class="hash-link" href="#submitrunnable" title="Direct link to heading">#</a></h5><p>   submit(Runnable)和execute(Runnable)区别是前者可以返回一个Future对象，通过返回的Future对象，我们可以检查提交的任务是否执行完毕，请看下面执行的例子：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Future future = executorService.submit(new Runnable() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">public void run() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;Asynchronous task&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">});</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">future.get();  //returns null if the task has finished correctly.</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><blockquote><p>注：如果任务执行完成，future.get()方法会返回一个null。注意，future.get()方法会产生阻塞。</p></blockquote><h5><a aria-hidden="true" tabindex="-1" class="anchor" id="invokeany"></a>invokeAny(…)<a class="hash-link" href="#invokeany" title="Direct link to heading">#</a></h5><p>invokeAny(...)方法接收的是一个Callable的集合，执行这个方法不会返回Future，但是会返回所有Callable任务中其中一个任务的执行结果。这个方法也无法保证返回的是哪个任务的执行结果，反正是其中的某一个</p><h5><a aria-hidden="true" tabindex="-1" class="anchor" id="invokeall"></a>invokeAll(…)<a class="hash-link" href="#invokeall" title="Direct link to heading">#</a></h5><p>invokeAll(...)与 invokeAny(...)类似也是接收一个Callable集合，但是前者执行之后会返回一个Future的List，其中对应着每个Callable任务执行后的Future对象</p><h5><a aria-hidden="true" tabindex="-1" class="anchor" id="executorservice关闭方法"></a>ExecutorService关闭方法<a class="hash-link" href="#executorservice关闭方法" title="Direct link to heading">#</a></h5><p> 当我们使用完成ExecutorService之后应该关闭它，否则它里面的线程会一直处于运行状态。举个例子，如果的应用程序是通过main()方法启动的，在这个main()退出之后，如果应用程序中的ExecutorService没有关闭，这个应用将一直运行。之所以会出现这种情况，是因为ExecutorService中运行的线程会阻止JVM关闭。</p><p>  要关闭ExecutorService中执行的线程，我们可以调用ExecutorService.shutdown()方法。在调用shutdown()方法之后，ExecutorService不会立即关闭，但是它不再接收新的任务，直到当前所有线程执行完成才会关闭，所有在shutdown()执行之前提交的任务都会被执行。</p><p>  如果想立即关闭ExecutorService，我们可以调用ExecutorService.shutdownNow()方法。这个动作将跳过所有正在执行的任务和被提交还没有执行的任务。但是它并不对正在执行的任务做任何保证，有可能它们都会停止，也有可能执行完成。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="死锁"></a>死锁<a class="hash-link" href="#死锁" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="死锁的四个必要条件"></a>死锁的四个必要条件<a class="hash-link" href="#死锁的四个必要条件" title="Direct link to heading">#</a></h4><ul><li>互斥条件：资源不能被共享，只能被同一个进程使用</li><li>请求与保持条件：已经得到资源的进程可以申请新的资源</li><li>非剥夺条件：已经分配的资源不能从相应的进程中被强制剥夺</li><li>循环等待条件：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程占用的资源</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="处理死锁的方法"></a>处理死锁的方法<a class="hash-link" href="#处理死锁的方法" title="Direct link to heading">#</a></h4><ul><li>忽略该问题，也即鸵鸟算法。当发生了什么问题时，不管他，直接跳过，无视它;</li><li>检测死锁并恢复;</li><li>资源进行动态分配;</li><li>破除上面的四种死锁条件之一;</li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Goldwood1024/docs.advanced.way/tree/master/docs/java/hc/多线程.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-07-06T06:05:23.000Z" class="lastUpdatedDate_1WI_">7/6/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs.advanced.way/docs/java/hc/高并发"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 高并发</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs.advanced.way/docs/java/hc/并发编程的艺术"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">并发编程的艺术 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#线程" class="table-of-contents__link">线程</a><ul><li><a href="#并发和并行" class="table-of-contents__link">并发和并行</a></li><li><a href="#线程状态" class="table-of-contents__link">线程状态</a></li><li><a href="#创建线程" class="table-of-contents__link">创建线程</a></li><li><a href="#线程管理" class="table-of-contents__link">线程管理</a></li><li><a href="#线程调度" class="table-of-contents__link">线程调度</a></li><li><a href="#线程同步" class="table-of-contents__link">线程同步</a></li><li><a href="#线程通信" class="table-of-contents__link">线程通信</a></li></ul></li><li><a href="#线程池" class="table-of-contents__link">线程池</a><ul><li><a href="#内置线程池" class="table-of-contents__link">内置线程池</a></li><li><a href="#线程池参数" class="table-of-contents__link">线程池参数</a></li><li><a href="#死锁" class="table-of-contents__link">死锁</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 进阶之路, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/docs.advanced.way/assets/js/runtime~main.aa1c8b94.js"></script>
<script src="/docs.advanced.way/assets/js/main.8fae9188.js"></script>
</body>
</html>