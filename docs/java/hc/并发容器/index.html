<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.75">
<link rel="alternate" type="application/rss+xml" href="/docs.advanced.way/blog/rss.xml" title="进阶之路 Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/docs.advanced.way/blog/atom.xml" title="进阶之路 Blog Atom Feed"><title data-react-helmet="true">并发容器 | 进阶之路</title><meta data-react-helmet="true" property="og:url" content="https://Goldwood1024.github.io/docs.advanced.way/docs/java/hc/并发容器"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="并发容器 | 进阶之路"><meta data-react-helmet="true" name="description" content="ConcurrentHashMap"><meta data-react-helmet="true" property="og:description" content="ConcurrentHashMap"><link data-react-helmet="true" rel="shortcut icon" href="/docs.advanced.way/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Goldwood1024.github.io/docs.advanced.way/docs/java/hc/并发容器"><link data-react-helmet="true" rel="alternate" href="https://Goldwood1024.github.io/docs.advanced.way/docs/java/hc/并发容器" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Goldwood1024.github.io/docs.advanced.way/docs/java/hc/并发容器" hreflang="x-default"><link rel="stylesheet" href="/docs.advanced.way/assets/css/styles.5e159b62.css">
<link rel="preload" href="/docs.advanced.way/assets/js/runtime~main.aa1c8b94.js" as="script">
<link rel="preload" href="/docs.advanced.way/assets/js/main.8fae9188.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top navbarHideable_2qcr"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/docs.advanced.way/"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">进阶之路</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs.advanced.way/docs/java/">Java</a><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link">生态</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/spring-family/">Spring家族</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/framework/mybatis/">常用框架</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/distributed/">分布式</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/cloud/docker/base/镜像/">容器</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/db/mysql/InnoDB/">数据库</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/zoology/os/network/tcpip/">计算机系统</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link">编码实践</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs.advanced.way/docs/algorithm/algorithm/">算法/数据结构</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/patterns/">设计模式</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/architecture/">系统架构</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/practice/memo/tool/sublime/">备忘录</a></li></ul></div></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/docs.advanced.way/blog">博客</a><a href="https://github.com/Goldwood1024/docs.advanced.way.git" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/docs.advanced.way/"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">进阶之路</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs.advanced.way/docs/java/">Java</a></li><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist">生态</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/spring-family/">Spring家族</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/framework/mybatis/">常用框架</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/distributed/">分布式</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/cloud/docker/base/镜像/">容器</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/db/mysql/InnoDB/">数据库</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/zoology/os/network/tcpip/">计算机系统</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist">编码实践</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/algorithm/algorithm/">算法/数据结构</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/patterns/">设计模式</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/architecture/">系统架构</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/practice/memo/tool/sublime/">备忘录</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/blog">博客</a></li><li class="menu__list-item"><a href="https://github.com/Goldwood1024/docs.advanced.way.git" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo sidebarWithHideableNavbar_267A"><a tabindex="-1" class="sidebarLogo_3h0W" href="/docs.advanced.way/"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--dark_hz6m"><strong>进阶之路</strong></a><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">基础</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/">简介</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/object">面向对象</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/数据类型">数据类型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/关键字">关键字</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/String">String</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/io">I/O</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/nio">NIO</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/Reference">对象引用</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/代理">代理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/函数式接口">函数式接口</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/反射">反射</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/base64">Base64编码</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/jdk">JDK</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">集合</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/collection/Collection">Collection</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/collection/List">List</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/collection/Map">Map</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">高并发</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/高并发">高并发</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/多线程">多线程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/并发编程的艺术">并发编程的艺术</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/内存模型">内存模型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/原子类">原子类</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs.advanced.way/docs/java/hc/并发容器">并发容器</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/并发工具类">并发工具类</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/线程池">线程池</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/锁">锁</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">JVM</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/对象创建过程">对象创建过程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/对象回收机制">对象回收机制</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/jvm参数">JVM参数</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/jvm内存模型">内存模型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/内存优化">内存优化</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/垃圾收集器">垃圾收集器</a></li></ul></li></ul></div><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_1CGd"><svg width="20" height="20" role="img" class="collapseSidebarButtonIcon_3E-R"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">并发容器</h1></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="concurrenthashmap"></a>ConcurrentHashMap<a class="hash-link" href="#concurrenthashmap" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="结构"></a>结构<a class="hash-link" href="#结构" title="Direct link to heading">#</a></h3><p><img src="/docs.advanced.way/assets/images/ConcurrentHashMap-4d91e2e7d773b275171bf9cca2bfeab0.png"></p><p>CAS无锁算法与synchronized保证并发安全，支持并发扩容，数据结构变更为数组+链表+红黑树，提高性能。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="源码"></a>源码<a class="hash-link" href="#源码" title="Direct link to heading">#</a></h3><p><img src="/docs.advanced.way/assets/images/1162587-20190217130653916-1383228669-83d3407356d1aa2a0e47cae207a2dfc3.png"></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public interface Map&lt;K, V&gt; {}</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">public interface ConcurrentMap&lt;K,V&gt; extends Map&lt;K,V&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">public abstract class AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public abstract Set&lt;Entry&lt;K,V&gt;&gt; entrySet();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p><code>Map</code> <a href="/docs.advanced.way/docs/java/collection/Map">接口定义</a></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    implements ConcurrentMap&lt;K,V&gt;, Serializable {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final int DEFAULT_CAPACITY = 16;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final int DEFAULT_CONCURRENCY_LEVEL = 16;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final float LOAD_FACTOR = 0.75f;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final int TREEIFY_THRESHOLD = 8;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final int UNTREEIFY_THRESHOLD = 6;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final int MIN_TREEIFY_CAPACITY = 64;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final int MIN_TRANSFER_STRIDE = 16;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final int RESIZE_STAMP_BITS = 16;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final int MOVED     = -1; // hash for forwarding nodes</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final int TREEBIN   = -2; // hash for roots of trees</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final int RESERVED  = -3; // hash for transient reservations</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    </span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final int NCPU = Runtime.getRuntime().availableProcessors();</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 创建空表</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    transient volatile Node&lt;K,V&gt;[] table;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 创建空表，扩容时使用</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private transient volatile Node&lt;K,V&gt;[] nextTable;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private transient volatile long baseCount;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 控制 table 初始化或扩容</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 0代表hash表还没有被初始化</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 负数代表正在进行初始化或扩容操作</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // -1代表正在初始化</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // -（N+1） 表示有N个线程正在进行扩容操作</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 正数数值表示下一次进行扩容的阈值，是当前ConcurrentHashMap容量的0.75倍，这与loadfactor是对应的</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private transient volatile int sizeCtl;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // Map.Entry 实现类</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final class MapEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final K key; // non-null</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        V val;       // non-null</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final ConcurrentHashMap&lt;K,V&gt; map;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        MapEntry(K key, V val, ConcurrentHashMap&lt;K,V&gt; map) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            this.key = key;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            this.val = val;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            this.map = map;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        public K getKey()        { return key; }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        public V getValue()      { return val; }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        public int hashCode()    { return key.hashCode() ^ val.hashCode(); }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        public String toString() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return Helpers.mapEntryToString(key, val);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        public boolean equals(Object o) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Object k, v; Map.Entry&lt;?,?&gt; e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return ((o instanceof Map.Entry) &amp;&amp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != null &amp;&amp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    (v = e.getValue()) != null &amp;&amp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    (k == key || k.equals(key)) &amp;&amp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    (v == val || v.equals(val)));</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        public V setValue(V value) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (value == null) throw new NullPointerException();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            V v = val;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            val = value;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            map.put(key, value);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return v;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public V put(K key, V value) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return putVal(key, value, false);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    final V putVal(K key, V value, boolean onlyIfAbsent) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // key value 都不能为空</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (key == null || value == null) throw new NullPointerException();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // hash 值</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int hash = spread(key.hashCode());</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 用于记录相应链表的长度</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int binCount = 0;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 自旋</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        for (Node&lt;K,V&gt;[] tab = table;;) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Node&lt;K,V&gt; f;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            int n, i, fh;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            K fk;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            V fv;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 初始化</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (tab == null || (n = tab.length) == 0)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                tab = initTable();</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 找该 hash 值对应的数组下标，得到第一个节点 f</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 如果数组该位置为空 用一次 CAS 操作将这个新值放入其中</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value)))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    // cas 成功退出</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    break;                   // no lock when adding to empty bin</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            else if ((fh = f.hash) == MOVED)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 帮助数据迁移</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                tab = helpTransfer(tab, f);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            else if (onlyIfAbsent // check first node without acquiring lock</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                     &amp;&amp; fh == hash</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                     &amp;&amp; ((fk = f.key) == key || (fk != null &amp;&amp; key.equals(fk)))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                     &amp;&amp; (fv = f.val) != null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                return fv;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            else {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                V oldVal = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // f 是该位置的头结点，而且不为空</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                synchronized (f) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if (tabAt(tab, i) == f) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        // 头结点的 hash 值大于 0，说明是链表</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        if (fh &gt;= 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            // 用于累加，记录链表的长度</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            binCount = 1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            for (Node&lt;K,V&gt; e = f;; ++binCount) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                K ek;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                // 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                if (e.hash == hash &amp;&amp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    ((ek = e.key) == key ||</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                     (ek != null &amp;&amp; key.equals(ek)))) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    oldVal = e.val;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    if (!onlyIfAbsent)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                        e.val = value;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    break;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                Node&lt;K,V&gt; pred = e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                // 到了链表的最末端，将这个新值放到链表的最后面</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                if ((e = e.next) == null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    pred.next = new Node&lt;K,V&gt;(hash, key, value);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    break;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        // 红黑树</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        else if (f instanceof TreeBin) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            Node&lt;K,V&gt; p;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            binCount = 2;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                                           value)) != null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                oldVal = p.val;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                if (!onlyIfAbsent)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    p.val = value;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        else if (f instanceof ReservationNode)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            throw new IllegalStateException(&quot;Recursive update&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // binCount != 0 说明上面在做链表操作</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (binCount != 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    // 判断是否要将链表转换为红黑树</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if (binCount &gt;= TREEIFY_THRESHOLD)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        treeifyBin(tab, i);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if (oldVal != null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        return oldVal;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        addCount(1L, binCount);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final int spread(int h) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 初始化一个合适大小的数组，然后会设置 sizeCtl</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private final Node&lt;K,V&gt;[] initTable() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;K,V&gt;[] tab; int sc;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        while ((tab = table) == null || tab.length == 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 初始化的操作被其他线程执行</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if ((sc = sizeCtl) &lt; 0)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                Thread.yield(); // lost initialization race; just spin</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            else if (U.compareAndSetInt(this, SIZECTL, sc, -1)) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                try {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if ((tab = table) == null || tab.length == 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        // 默认容量大小</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        // 初始化 Node 数组</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        table = tab = nt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        sc = n - (n &gt;&gt;&gt; 2);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                } finally {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    // 12</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    sizeCtl = sc;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                break;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return tab;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">     private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;K,V&gt; b; int n;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (tab != null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 数组小于 64，扩容</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 加倍</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                tryPresize(n &lt;&lt; 1);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 树化</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                synchronized (b) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if (tabAt(tab, index) == b) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        TreeNode&lt;K,V&gt; hd = null, tl = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        for (Node&lt;K,V&gt; e = b; e != null; e = e.next) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            TreeNode&lt;K,V&gt; p =</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                                  null, null);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            if ((p.prev = tl) == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                hd = p;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            else</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                tl.next = p;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            tl = p;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // ABASE 表示 table中首个元素的内存偏移地址，所以(long)i &lt;&lt; ASHIFT) + ABASE 得到 table[i] 的内存偏移地</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return (Node&lt;K,V&gt;)U.getObjectAcquire(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return U.compareAndSetObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 1. 检测是否需要扩容 2. 更新结点数量</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private final void addCount(long x, int check) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        CounterCell[] cs; long b, s;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if ((cs = counterCells) != null ||</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            !U.compareAndSetLong(this, BASECOUNT, b = baseCount, s = b + x)) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            CounterCell c; long v; int m;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            boolean uncontended = true;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (cs == null || (m = cs.length - 1) &lt; 0 ||</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                (c = cs[ThreadLocalRandom.getProbe() &amp; m]) == null ||</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                !(uncontended =</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                  U.compareAndSetLong(c, CELLVALUE, v = c.value, v + x))) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                fullAddCount(x, uncontended);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                return;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (check &lt;= 1)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                return;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            s = sumCount();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (check &gt;= 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Node&lt;K,V&gt;[] tab, nt; int n, sc;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                   (n = tab.length) &lt; MAXIMUM_CAPACITY) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                int rs = resizeStamp(n);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (sc &lt; 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        transferIndex &lt;= 0)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        break;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if (U.compareAndSetInt(this, SIZECTL, sc, sc + 1))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        transfer(tab, nt);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                else if (U.compareAndSetInt(this, SIZECTL, sc,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    transfer(tab, null);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                s = sumCount();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // put，remove等情况下遇到扩容，如果当前当前线程遇到Forwarding结点，</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 发现正在扩容，就会帮助扩容；如果没有发现扩容，那么仍然可以继续操作</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;K,V&gt;[] nextTab; int sc;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            int rs = resizeStamp(tab.length);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                   (sc = sizeCtl) &lt; 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 通过CAS操作获取扩容名额</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (U.compareAndSetInt(this, SIZECTL, sc, sc + 1)) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    // 数据迁移</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    transfer(tab, nextTab);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return nextTab;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return table;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private final void tryPresize(int size) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int sc;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        while ((sc = sizeCtl) &gt;= 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Node&lt;K,V&gt;[] tab = table; int n;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 初始化数组</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (tab == null || (n = tab.length) == 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                n = (sc &gt; c) ? sc : c;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (U.compareAndSetInt(this, SIZECTL, sc, -1)) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    try {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        if (table == tab) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            @SuppressWarnings(&quot;unchecked&quot;)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            table = nt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            sc = n - (n &gt;&gt;&gt; 2);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    } finally {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        sizeCtl = sc;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                break;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            else if (tab == table) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                int rs = resizeStamp(n);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (U.compareAndSetInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    transfer(tab, null);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final int tableSizeFor(int c) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int n = -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(c - 1);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int n = tab.length, stride;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // NCPU = cpu 核心数</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 计算每条线程处理的桶个数，每条线程处理的桶数量一样；每个线程处理桶的最小数目，可以看出核数越高步长越小，最小16个，。</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            stride = MIN_TRANSFER_STRIDE; // subdivide range</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 还未指定下一个表，则新建目标表的大小；</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (nextTab == null) {            // initiating</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            try {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                @SuppressWarnings(&quot;unchecked&quot;)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                nextTab = nt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            } catch (Throwable ex) {      // try to cope with OOME</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                sizeCtl = Integer.MAX_VALUE;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                return;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            nextTable = nextTab;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 扩容总进度，&gt;=transferIndex的桶都已分配出去</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            transferIndex = n;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int nextn = nextTab.length;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 标明此节点正在进行迁移，扩容期间的元素查找要调用其find()方法在nextTable中查找元素。</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        </span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 当前线程是否需要继续寻找下一个可处理的节点</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        boolean advance = true;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 所有桶是否都已迁移完成</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        boolean finishing = false; // to ensure sweep before committing nextTab</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0, bound = 0;;) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Node&lt;K,V&gt; f; int fh;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            while (advance) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                int nextIndex, nextBound;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 处理一个桶就i减1</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (--i &gt;= bound || finishing)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    advance = false;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 迁移总进度&lt;=0，表示所有桶都已迁移完成，i置-1，advance为false，后续根据这个退出扩容</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                else if ((nextIndex = transferIndex) &lt;= 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    i = -1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    advance = false;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 首次进入for循环会进入该函数，设置任务区间</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                else if (U.compareAndSetInt</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                         (this, TRANSFERINDEX, nextIndex,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                          nextBound = (nextIndex &gt; stride ?</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                       nextIndex - stride : 0))) {// transferIndex减去已分配出去的桶。</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    // 确定当前线程每次分配的待迁移桶的范围为[bound, nextIndex)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    bound = nextBound;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    i = nextIndex - 1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    advance = false;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 扩容结束，nextTable 只有扩容时才不为null；将table指向新表，重新设置sizeCtl</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                int sc;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (finishing) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    nextTable = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    table = nextTab;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    return;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 每当一条线程扩容结束就会更新一次 sizeCtl 的值，进行减1操作,扩容中，sizeCtl表示有多少个线程</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (U.compareAndSetInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    // 还记得addCount()处给sizeCtl赋的初值吗？相等时说明没有线程在参与扩容了，</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    // 置finishing=advance=true，为保险让i=n再检查一次。</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        return;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    // 将i设置为n，再重新检查是不是所有的结点都完成转移了</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    finishing = advance = true;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    i = n; // recheck before commit</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 空桶，放fwd标识扩容状态</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            else if ((f = tabAt(tab, i)) == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 如果i处是ForwardingNode表示第i个桶已经有线程在负责迁移了。</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                advance = casTabAt(tab, i, null, fwd);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 已经放置了fwd，扩容了，检查下一个</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            else if ((fh = f.hash) == MOVED)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                advance = true; // already processed</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            else {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 桶内元素迁移需要加锁</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                synchronized (f) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if (tabAt(tab, i) == f) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        Node&lt;K,V&gt; ln, hn;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        if (fh &gt;= 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            // 由于n是2的幂次方（所有二进制位中只有一个1)，如n=16(0001 0000)，第4位为1，那么hash&amp;n后的值第4位只能为0或1。</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            // 所以可以根据hash&amp;n的结果将所有结点分为两部分。</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            int runBit = fh &amp; n;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            Node&lt;K,V&gt; lastRun = f;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                int b = p.hash &amp; n;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                if (b != runBit) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    runBit = b;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    lastRun = p;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            if (runBit == 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                ln = lastRun;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                hn = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            else {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                hn = lastRun;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                ln = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            // 找出最后一段完整的 fh&amp;n 不变的链表，这样最后这一段链表就不用重新创建新结点了</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                int ph = p.hash; K pk = p.key; V pv = p.val;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                if ((ph &amp; n) == 0)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                else</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            // 低位链表放在i处</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            setTabAt(nextTab, i, ln);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            // 高位链表放在i+n处</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            setTabAt(nextTab, i + n, hn);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            setTabAt(tab, i, fwd);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            advance = true;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        else if (f instanceof TreeBin) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            TreeNode&lt;K,V&gt; lo = null, loTail = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            TreeNode&lt;K,V&gt; hi = null, hiTail = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            int lc = 0, hc = 0;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                int h = e.hash;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    (h, e.key, e.val, null, null);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                if ((h &amp; n) == 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    if ((p.prev = loTail) == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                        lo = p;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    else</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                        loTail.next = p;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    loTail = p;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    ++lc;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                else {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    if ((p.prev = hiTail) == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                        hi = p;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    else</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                        hiTail.next = p;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    hiTail = p;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                    ++hc;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            setTabAt(nextTab, i, ln);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            setTabAt(nextTab, i + n, hn);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            setTabAt(tab, i, fwd);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            advance = true;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final Node&lt;K,V&gt;[] nextTable;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        ForwardingNode(Node&lt;K,V&gt;[] tab) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            super(MOVED, null, null);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            this.nextTable = tab;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;K,V&gt; find(int h, Object k) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // loop to avoid arbitrarily deep recursion on forwarding nodes</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            outer: for (Node&lt;K,V&gt;[] tab = nextTable;;) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                Node&lt;K,V&gt; e; int n;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (k == null || tab == null || (n = tab.length) == 0 ||</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    (e = tabAt(tab, (n - 1) &amp; h)) == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    return null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                for (;;) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    int eh; K ek;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if ((eh = e.hash) == h &amp;&amp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        return e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if (eh &lt; 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        if (e instanceof ForwardingNode) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            continue outer;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        else</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            return e.find(h, k);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if ((e = e.next) == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        return null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public V get(Object key) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 计算hash值</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int h = spread(key.hashCode());</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 判断头结点是否就是我们需要的节点</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if ((eh = e.hash) == h) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    return e.val;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 如果头结点的 hash 小于 0，说明 正在扩容或者该位置是红黑树</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            else if (eh &lt; 0)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                return (p = e.find(h, key)) != null ? p.val : null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 遍历链表</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            while ((e = e.next) != null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (e.hash == h &amp;&amp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    return e.val;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>put 方法流程:</p><ul><li>根据 key 计算出 hashcode 。</li><li>判断表是否需要进行初始化。</li><li>定位出的目标桶，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋。</li><li>如果当前位置的 hashcode == MOVED == -1,则帮助扩容，扩容完成后才进行插入。</li><li>如果没有特殊情况，则利用 synchronized 锁写入数据。</li><li>如果数量大于 TREEIFY_THRESHOLD（8） 则要转换为红黑树。</li><li>插入完成，我们判断一下是不是要扩容，并记录一下Node数量;方便统计</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="concurrentlinkedqueue"></a>ConcurrentLinkedQueue<a class="hash-link" href="#concurrentlinkedqueue" title="Direct link to heading">#</a></h2><p>一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="架构图"></a>架构图<a class="hash-link" href="#架构图" title="Direct link to heading">#</a></h3><p><img src="/docs.advanced.way/assets/images/ConcurrentLinkedQueue-df6dd5aa5b04a54d1b05c9da27c4e841.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="源码-1"></a>源码<a class="hash-link" href="#源码-1" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public class ConcurrentLinkedQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        implements Queue&lt;E&gt;, java.io.Serializable {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    transient volatile Node&lt;E&gt; head;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private transient volatile Node&lt;E&gt; tail;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final VarHandle HEAD;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final VarHandle TAIL;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final VarHandle ITEM;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final VarHandle NEXT;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public ConcurrentLinkedQueue() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        head = tail = new Node&lt;E&gt;();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final class Node&lt;E&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        volatile E item;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        volatile Node&lt;E&gt; next;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        /**</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         * Constructs a node holding item.  Uses relaxed write because</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         * item can only be seen after piggy-backing publication via CAS.</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         */</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node(E item) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            ITEM.set(this, item);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        /** Constructs a dead dummy node. */</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node() {}</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        void appendRelaxed(Node&lt;E&gt; next) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // assert next != null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // assert this.next == null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            NEXT.set(this, next);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        boolean casItem(E cmp, E val) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // assert item == cmp || item == null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // assert cmp != null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // assert val == null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return ITEM.compareAndSet(this, cmp, val);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public boolean add(E e) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return offer(e);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 入队</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public boolean offer(E e) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 创建节点</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final Node&lt;E&gt; newNode = new Node&lt;E&gt;(Objects.requireNonNull(e));</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 根据tail节点定位出尾节点</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        for (Node&lt;E&gt; t = tail, p = t;;) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Node&lt;E&gt; q = p.next;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 放入尾部</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (q == null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // p is last node</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 将新节点置为尾节点的下一个节点</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (NEXT.compareAndSet(p, null, newNode)) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    // Successful CAS is the linearization point</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    // for e to become an element of this queue,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    // and for newNode to become &quot;live&quot;.</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if (p != t) // hop two nodes at a time; failure is OK</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        TAIL.weakCompareAndSet(this, t, newNode);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    return true;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // Lost CAS race to another thread; re-read next</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            else if (p == q)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // We have fallen off list.  If tail is unchanged, it</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // will also be off-list, in which case we need to</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // jump to head, from which all live nodes are always</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // reachable.  Else the new tail is a better bet.</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                p = (t != (t = tail)) ? t : head;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            else</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 寻找尾节点</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // Check for tail updates after two hops.</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 出队</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public E poll() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        restartFromHead: for (;;) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            for (Node&lt;E&gt; h = head, p = h, q;; p = q) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                final E item;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if ((item = p.item) != null &amp;&amp; p.casItem(item, null)) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    // Successful CAS is the linearization point</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    // for item to be removed from this queue.</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if (p != h) // hop two nodes at a time</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        updateHead(h, ((q = p.next) != null) ? q : p);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    return item;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                else if ((q = p.next) == null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    updateHead(h, p);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    return null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                else if (p == q)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    continue restartFromHead;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        </span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="copyonwritearraylist"></a>CopyOnWriteArrayList<a class="hash-link" href="#copyonwritearraylist" title="Direct link to heading">#</a></h2><p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。
其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略</p><p>CopyOnWrite并发容器用于读多写少的并发场景 比如: 白名单，黑名单，商品类目的访问和更新场景</p><p>缺点:</p><ul><li><p>内存占用问题 因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象</p></li><li><p>数据一致性问题 只能保证数据的最终一致性，不能保证数据的实时一致性</p></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="架构图-1"></a>架构图<a class="hash-link" href="#架构图-1" title="Direct link to heading">#</a></h3><p><img src="/docs.advanced.way/assets/images/CopyOnWriteArrayList-b850551cbe36bf1acd54acfe4c221245.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="源码-2"></a>源码<a class="hash-link" href="#源码-2" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public class CopyOnWriteArrayList&lt;E&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    final transient Object lock = new Object();</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 容器</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private transient volatile Object[] array;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    final Object[] getArray() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return array;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    final void setArray(Object[] a) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        array = a;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 默认构造器</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public CopyOnWriteArrayList() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        setArray(new Object[0]);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 获取元素</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public E get(int index) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return elementAt(getArray(), index);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static &lt;E&gt; E elementAt(Object[] a, int index) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return (E) a[index];</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public boolean add(E e) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 加锁</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        synchronized (lock) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 获取容器</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Object[] es = getArray();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            int len = es.length;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 复制出新数组</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            es = Arrays.copyOf(es, len + 1);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 把新元素添加到新数组里</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            es[len] = e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 把原数组引用指向新数组</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            setArray(es);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return true;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="阻塞队列"></a>阻塞队列<a class="hash-link" href="#阻塞队列" title="Direct link to heading">#</a></h2><p>支持两个附加操作的队列</p><ul><li>支持阻塞的插入方法</li></ul><p>队列满时，队列阻塞插入元素的线程</p><ul><li>支持阻塞的移除方法</li></ul><p>队列为空时，获取元素的线程会等待队列为非空</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="核心类"></a>核心类<a class="hash-link" href="#核心类" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="blockingqueueclass"></a>BlockingQueue.class<a class="hash-link" href="#blockingqueueclass" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt;{</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="abstractqueueclass"></a>AbstractQueue.class<a class="hash-link" href="#abstractqueueclass" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public abstract class AbstractQueue&lt;E&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    extends AbstractCollection&lt;E&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    implements Queue&lt;E&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="arrayblockingqueue"></a>ArrayBlockingQueue<a class="hash-link" href="#arrayblockingqueue" title="Direct link to heading">#</a></h3><p>一个数组实现的有界队列（FIFO）</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        implements BlockingQueue&lt;E&gt;, java.io.Serializable {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    </span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 容器</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    final Object[] items;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 元素个数</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    int count;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    final ReentrantLock lock;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private final Condition notEmpty;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private final Condition notFull;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 默认非公平</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public ArrayBlockingQueue(int capacity) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        this(capacity, false);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 可以指定访问模式（公平或非公平）</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public ArrayBlockingQueue(int capacity, boolean fair) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (capacity &lt;= 0)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalArgumentException();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        this.items = new Object[capacity];</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        lock = new ReentrantLock(fair);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        notEmpty = lock.newCondition();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        notFull =  lock.newCondition();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 插入元素</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public boolean offer(E e) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Objects.requireNonNull(e);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final ReentrantLock lock = this.lock;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        lock.lock();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        try {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (count == items.length)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                return false;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            else {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                enqueue(e);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                return true;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public void put(E e) throws InterruptedException {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Objects.requireNonNull(e);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final ReentrantLock lock = this.lock;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        lock.lockInterruptibly();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        try {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 检查是否已满</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            while (count == items.length)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                notFull.await();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            enqueue(e);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private void enqueue(E e) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // assert lock.isHeldByCurrentThread();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // assert lock.getHoldCount() == 1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // assert items[putIndex] == null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final Object[] items = this.items;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 放入数组</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        items[putIndex] = e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (++putIndex == items.length) putIndex = 0;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        count++;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        notEmpty.signal();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public E take() throws InterruptedException {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final ReentrantLock lock = this.lock;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        lock.lockInterruptibly();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        try {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            while (count == 0)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 阻塞</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                notEmpty.await();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return dequeue();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private E dequeue() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // assert lock.isHeldByCurrentThread();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // assert lock.getHoldCount() == 1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // assert items[takeIndex] != null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final Object[] items = this.items;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        @SuppressWarnings(&quot;unchecked&quot;)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        E e = (E) items[takeIndex];</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 置空</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        items[takeIndex] = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (++takeIndex == items.length) takeIndex = 0;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        count--;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (itrs != null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            itrs.elementDequeued();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        notFull.signal();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public int size() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final ReentrantLock lock = this.lock;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        lock.lock();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        try {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return count;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="linkedblockingqueue"></a>LinkedBlockingQueue<a class="hash-link" href="#linkedblockingqueue" title="Direct link to heading">#</a></h3><p>链表实现的有界阻塞队列</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        implements BlockingQueue&lt;E&gt;, java.io.Serializable {</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private final int capacity;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private final AtomicInteger count = new AtomicInteger();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    transient Node&lt;E&gt; head;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private transient Node&lt;E&gt; last;        </span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static class Node&lt;E&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        E item;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        /**</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         * One of:</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         * - the real successor Node</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         * - this Node, meaning the successor is head.next</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         * - null, meaning there is no successor (this is the last node)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         */</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;E&gt; next;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node(E x) { item = x; }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // Integer.MAX_VALUE</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public LinkedBlockingQueue() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        this(Integer.MAX_VALUE);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 指定容量</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public LinkedBlockingQueue(int capacity) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (capacity &lt;= 0) throw new IllegalArgumentException();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        this.capacity = capacity;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        last = head = new Node&lt;E&gt;(null);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public void put(E e) throws InterruptedException {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (e == null) throw new NullPointerException();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final int c;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final Node&lt;E&gt; node = new Node&lt;E&gt;(e);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final ReentrantLock putLock = this.putLock;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final AtomicInteger count = this.count;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        putLock.lockInterruptibly();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        try {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 判断是否已满</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            while (count.get() == capacity) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                notFull.await();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            enqueue(node);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            c = count.getAndIncrement();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (c + 1 &lt; capacity)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                notFull.signal();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            putLock.unlock();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (c == 0)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            signalNotEmpty();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }   </span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 放入尾部</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private void enqueue(Node&lt;E&gt; node) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        last = last.next = node;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }    </span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public E take() throws InterruptedException {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final E x;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final int c;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final AtomicInteger count = this.count;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final ReentrantLock takeLock = this.takeLock;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        takeLock.lockInterruptibly();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        try {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 是否为空</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            while (count.get() == 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                notEmpty.await();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            x = dequeue();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 元素数量减一</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            c = count.getAndDecrement();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (c &gt; 1)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                notEmpty.signal();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            takeLock.unlock();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (c == capacity)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            signalNotFull();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return x;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private E dequeue() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // assert takeLock.isHeldByCurrentThread();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // assert head.item == null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;E&gt; h = head;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 取头结点下一个节点</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;E&gt; first = h.next;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        h.next = h; // help GC</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 重新指向头结点</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        head = first;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        E x = first.item;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        first.item = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return x;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="linkedtransferqueue"></a>LinkedTransferQueue<a class="hash-link" href="#linkedtransferqueue" title="Direct link to heading">#</a></h3><p>链表结构的无界阻塞队列</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public class LinkedTransferQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    implements TransferQueue&lt;E&gt;, java.io.Serializable  {</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final class Node {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final boolean isData;   // false if this is a request node</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        volatile Object item;   // initially non-null if isData; CASed to match</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        volatile Node next;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        volatile Thread waiter; // null when not waiting for a match</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        /**</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         * Constructs a data node holding item if item is non-null,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         * else a request node.  Uses relaxed write because item can</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         * only be seen after piggy-backing publication via CAS.</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         */</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node(Object item) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            ITEM.set(this, item);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            isData = (item != null);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        /** Constructs a (matched data) dummy node. */</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            isData = true;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="linkedblockingdeque"></a>LinkedBlockingDeque<a class="hash-link" href="#linkedblockingdeque" title="Direct link to heading">#</a></h3><p>链表结构的双向阻塞队列</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public class LinkedBlockingDeque&lt;E&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    extends AbstractQueue&lt;E&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    implements BlockingDeque&lt;E&gt;, java.io.Serializable {</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    static final class Node&lt;E&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        /**</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         * The item, or null if this node has been removed.</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         */</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        E item;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        /**</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         * One of:</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         * - the real predecessor Node</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         * - this Node, meaning the predecessor is tail</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         * - null, meaning there is no predecessor</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         */</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;E&gt; prev;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        /**</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         * One of:</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         * - the real successor Node</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         * - this Node, meaning the successor is head</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         * - null, meaning there is no successor</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         */</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;E&gt; next;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node(E x) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            item = x;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    transient Node&lt;E&gt; first;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    transient Node&lt;E&gt; last;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">     /** Number of items in the deque */</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private transient int count;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    /** Maximum number of items in the deque */</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private final int capacity;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public LinkedBlockingDeque() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        this(Integer.MAX_VALUE);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public LinkedBlockingDeque(int capacity) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (capacity &lt;= 0) throw new IllegalArgumentException();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        this.capacity = capacity;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public boolean offerFirst(E e) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (e == null) throw new NullPointerException();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;E&gt; node = new Node&lt;E&gt;(e);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final ReentrantLock lock = this.lock;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        lock.lock();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        try {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return linkFirst(node);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private boolean linkFirst(Node&lt;E&gt; node) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // assert lock.isHeldByCurrentThread();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (count &gt;= capacity)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return false;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;E&gt; f = first;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        node.next = f;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        first = node;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (last == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            last = node;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        else</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            f.prev = node;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        ++count;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        notEmpty.signal();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return true;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public E pollFirst() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final ReentrantLock lock = this.lock;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        lock.lock();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        try {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return unlinkFirst();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private E unlinkFirst() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // assert lock.isHeldByCurrentThread();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;E&gt; f = first;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (f == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;E&gt; n = f.next;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        E item = f.item;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        f.item = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        f.next = f; // help GC</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        first = n;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (n == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            last = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        else</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            n.prev = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        --count;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        notFull.signal();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return item;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="priorityblockingqueue"></a>PriorityBlockingQueue<a class="hash-link" href="#priorityblockingqueue" title="Direct link to heading">#</a></h3><blockquote><p>Priority [praɪˈɒrəti], Blocking [blɒkɪŋ] queue  [kjuː]</p></blockquote><p>支持优先级的无界阻塞队列</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public class PriorityBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    implements BlockingQueue&lt;E&gt;, java.io.Serializable {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final int DEFAULT_INITIAL_CAPACITY = 11;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private transient Object[] queue;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private transient int size;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private transient Comparator&lt;? super E&gt; comparator;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private PriorityQueue&lt;E&gt; q;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 默认容量，自然序排列</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public PriorityBlockingQueue() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        this(DEFAULT_INITIAL_CAPACITY, null);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 指定容量（最小为1）</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public PriorityBlockingQueue(int initialCapacity,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                 Comparator&lt;? super E&gt; comparator) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (initialCapacity &lt; 1)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalArgumentException();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        this.comparator = comparator;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        this.queue = new Object[Math.max(1, initialCapacity)];</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public void put(E e) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        offer(e); // 不需要阻塞</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public boolean offer(E e) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (e == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            throw new NullPointerException();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final ReentrantLock lock = this.lock;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        lock.lock();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int n, cap;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Object[] es;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        while ((n = size) &gt;= (cap = (es = queue).length))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            tryGrow(es, cap);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        try {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            final Comparator&lt;? super E&gt; cmp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if ((cmp = comparator) == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                siftUpComparable(n, e, es);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            else</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                siftUpUsingComparator(n, e, es, cmp);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            size = n + 1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            notEmpty.signal();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return true;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public E take() throws InterruptedException {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final ReentrantLock lock = this.lock;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        lock.lockInterruptibly();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        E result;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        try {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            while ( (result = dequeue()) == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                notEmpty.await();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return result;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private E dequeue() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // assert lock.isHeldByCurrentThread();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final Object[] es;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final E result;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if ((result = (E) ((es = queue)[0])) != null) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            final int n;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            final E x = (E) es[(n = --size)];</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            es[n] = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (n &gt; 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                final Comparator&lt;? super E&gt; cmp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if ((cmp = comparator) == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    siftDownComparable(0, x, es, n);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                else</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    siftDownUsingComparator(0, x, es, n, cmp);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return result;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="delayqueue"></a>DelayQueue<a class="hash-link" href="#delayqueue" title="Direct link to heading">#</a></h3><p>支持延时获取元素的无界队列，队列中的元素需要实现 <code>Delayed</code> 接口</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">public class DelayQueue&lt;E extends Delayed&gt; extends AbstractQueue&lt;E&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    implements BlockingQueue&lt;E&gt;{</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;();</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public DelayQueue() {}</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 添加元素</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public boolean offer(E e) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final ReentrantLock lock = this.lock;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        lock.lock();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        try {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 插入队列中</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            q.offer(e);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (q.peek() == e) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                leader = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                available.signal();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return true;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public E take() throws InterruptedException {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        final ReentrantLock lock = this.lock;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        lock.lockInterruptibly();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        try {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            for (;;) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                E first = q.peek();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                // 头元素为空null时阻塞</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                if (first == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    available.await();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                else {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    // 剩余延迟时间</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    long delay = first.getDelay(NANOSECONDS);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if (delay &lt;= 0L)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        // 弹出头元素</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        return q.poll();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    first = null; // don&#x27;t retain ref while waiting</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if (leader != null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        available.await();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    else {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        Thread thisThread = Thread.currentThread();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        leader = thisThread;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        try {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            available.awaitNanos(delay);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        } finally {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            if (leader == thisThread)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                leader = null;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (leader == null &amp;&amp; q.peek() != null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                available.signal();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="priorityqueue"></a>PriorityQueue<a class="hash-link" href="#priorityqueue" title="Direct link to heading">#</a></h4><p>优先级队列</p><p>PriorityQueue 底层通过数组来实现元素的存储</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;{</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static final int DEFAULT_INITIAL_CAPACITY = 11;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 队列的元素保存在数组queue中，其数据结构为最小堆，也就是用数组表示的完全二叉树</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    transient Object[] queue;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    int size;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    transient int modCount;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public PriorityQueue(int initialCapacity,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                         Comparator&lt;? super E&gt; comparator) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // Note: This restriction of at least one is not actually needed,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // but continues for 1.5 compatibility</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (initialCapacity &lt; 1)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalArgumentException();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        this.queue = new Object[initialCapacity];</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        this.comparator = comparator;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 插入元素</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public boolean offer(E e) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (e == null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            throw new NullPointerException();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 修改次数</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        modCount++;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int i = size;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (i &gt;= queue.length)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            grow(i + 1);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        siftUp(i, e);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        size = i + 1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return true;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private void siftUp(int k, E x) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (comparator != null)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 基于comparator属性进行大小比较</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            siftUpUsingComparator(k, x, queue, comparator);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        else</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            // 根据元素自身进行排序</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            siftUpComparable(k, x, queue);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static &lt;T&gt; void siftUpComparable(int k, T x, Object[] es) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;) x;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        while (k &gt; 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            int parent = (k - 1) &gt;&gt;&gt; 1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Object e = es[parent];</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (key.compareTo((T) e) &gt;= 0)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                break;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            es[k] = e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            k = parent;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        es[k] = key;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static &lt;T&gt; void siftUpUsingComparator(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int k, T x, Object[] es, Comparator&lt;? super T&gt; cmp) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        while (k &gt; 0) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            int parent = (k - 1) &gt;&gt;&gt; 1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Object e = es[parent];</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            if (cmp.compare(x, (T) e) &gt;= 0)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                break;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            es[k] = e;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            k = parent;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        es[k] = x;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 扩容 小于64扩容两倍+2，否则扩容1.5倍</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private void grow(int minCapacity) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int oldCapacity = queue.length;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // Double size if small; else grow by 50%</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ?</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                         (oldCapacity + 2) :</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                         (oldCapacity &gt;&gt; 1));</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // overflow-conscious code</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            newCapacity = hugeCapacity(minCapacity);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // 复制数据</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        queue = Arrays.copyOf(queue, newCapacity);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    private static int hugeCapacity(int minCapacity) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        if (minCapacity &lt; 0) // overflow</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            throw new OutOfMemoryError();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Integer.MAX_VALUE :</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            MAX_ARRAY_SIZE;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // 头元素</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    public E peek() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        return (E) queue[0];</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="小顶堆"></a>小顶堆<a class="hash-link" href="#小顶堆" title="Direct link to heading">#</a></h4><p><img src="/docs.advanced.way/assets/images/1078540-20191219134028689-155327191-0f0075db90108270be9d753639416663.png"></p><p>元素节点关系</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">leftNo = parentNo * 2 + 1</span></div><div class="token-line" style="color:#393A34"><span class="token plain">rightNo = parentNo * 2 + 2</span></div><div class="token-line" style="color:#393A34"><span class="token plain">parentNo = (currentNo -1) / 2</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">parentNo：表示父节点下标；</span></div><div class="token-line" style="color:#393A34"><span class="token plain">leftNo：表示子元素左节点下标；</span></div><div class="token-line" style="color:#393A34"><span class="token plain">rightNo：表示子元素右节点下标；</span></div><div class="token-line" style="color:#393A34"><span class="token plain">currentNo：表示当前元素节点下标；</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标</p><p><img src="/docs.advanced.way/assets/images/1078540-20191219134058870-285989691-a01a249edd93790d561db70cc67d472b.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="参考"></a>参考<a class="hash-link" href="#参考" title="Direct link to heading">#</a></h2><p><a href="https://blog.csdn.net/qq_38293564/article/details/80798310" target="_blank" rel="noopener noreferrer">Java并发编程之ConcurrentLinkedQueue详解</a></p><p><a href="https://www.cnblogs.com/dxflqm/p/12067265.html" target="_blank" rel="noopener noreferrer">深入浅出分析 PriorityQueue</a></p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Goldwood1024/docs.advanced.way/tree/master/docs/java/hc/并发容器.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-07-06T06:05:23.000Z" class="lastUpdatedDate_1WI_">7/6/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs.advanced.way/docs/java/hc/原子类"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 原子类</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs.advanced.way/docs/java/hc/并发工具类"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">并发工具类 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#concurrenthashmap" class="table-of-contents__link">ConcurrentHashMap</a><ul><li><a href="#结构" class="table-of-contents__link">结构</a></li><li><a href="#源码" class="table-of-contents__link">源码</a></li></ul></li><li><a href="#concurrentlinkedqueue" class="table-of-contents__link">ConcurrentLinkedQueue</a><ul><li><a href="#架构图" class="table-of-contents__link">架构图</a></li><li><a href="#源码-1" class="table-of-contents__link">源码</a></li></ul></li><li><a href="#copyonwritearraylist" class="table-of-contents__link">CopyOnWriteArrayList</a><ul><li><a href="#架构图-1" class="table-of-contents__link">架构图</a></li><li><a href="#源码-2" class="table-of-contents__link">源码</a></li></ul></li><li><a href="#阻塞队列" class="table-of-contents__link">阻塞队列</a><ul><li><a href="#核心类" class="table-of-contents__link">核心类</a></li><li><a href="#arrayblockingqueue" class="table-of-contents__link">ArrayBlockingQueue</a></li><li><a href="#linkedblockingqueue" class="table-of-contents__link">LinkedBlockingQueue</a></li><li><a href="#linkedtransferqueue" class="table-of-contents__link">LinkedTransferQueue</a></li><li><a href="#linkedblockingdeque" class="table-of-contents__link">LinkedBlockingDeque</a></li><li><a href="#priorityblockingqueue" class="table-of-contents__link">PriorityBlockingQueue</a></li><li><a href="#delayqueue" class="table-of-contents__link">DelayQueue</a></li></ul></li><li><a href="#参考" class="table-of-contents__link">参考</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 进阶之路, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/docs.advanced.way/assets/js/runtime~main.aa1c8b94.js"></script>
<script src="/docs.advanced.way/assets/js/main.8fae9188.js"></script>
</body>
</html>