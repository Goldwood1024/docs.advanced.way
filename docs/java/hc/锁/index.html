<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.72">
<link rel="alternate" type="application/rss+xml" href="/docs.advanced.way/blog/rss.xml" title="进阶之路 Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/docs.advanced.way/blog/atom.xml" title="进阶之路 Blog Atom Feed"><title data-react-helmet="true">锁 | 进阶之路</title><meta data-react-helmet="true" property="og:url" content="https://Goldwood1024.github.io/docs.advanced.way/docs/java/hc/锁"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="锁 | 进阶之路"><meta data-react-helmet="true" name="description" content="java 中的锁"><meta data-react-helmet="true" property="og:description" content="java 中的锁"><link data-react-helmet="true" rel="shortcut icon" href="/docs.advanced.way/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Goldwood1024.github.io/docs.advanced.way/docs/java/hc/锁"><link data-react-helmet="true" rel="alternate" href="https://Goldwood1024.github.io/docs.advanced.way/docs/java/hc/锁" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Goldwood1024.github.io/docs.advanced.way/docs/java/hc/锁" hreflang="x-default"><link rel="stylesheet" href="/docs.advanced.way/assets/css/styles.a150e3cc.css">
<link rel="preload" href="/docs.advanced.way/assets/js/styles.ddded6a8.js" as="script">
<link rel="preload" href="/docs.advanced.way/assets/js/runtime~main.5d198aef.js" as="script">
<link rel="preload" href="/docs.advanced.way/assets/js/main.131ff777.js" as="script">
<link rel="preload" href="/docs.advanced.way/assets/js/1.6e33c73b.js" as="script">
<link rel="preload" href="/docs.advanced.way/assets/js/2.88860bc9.js" as="script">
<link rel="preload" href="/docs.advanced.way/assets/js/3.52177707.js" as="script">
<link rel="preload" href="/docs.advanced.way/assets/js/1be78505.9a733b12.js" as="script">
<link rel="preload" href="/docs.advanced.way/assets/js/198.598f71db.js" as="script">
<link rel="preload" href="/docs.advanced.way/assets/js/935f2afb.dbe87953.js" as="script">
<link rel="preload" href="/docs.advanced.way/assets/js/17896441.71928309.js" as="script">
<link rel="preload" href="/docs.advanced.way/assets/js/40065f64.c8983bd3.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top navbarHideable_2qcr"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/docs.advanced.way/"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">进阶之路</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs.advanced.way/docs/java/">Java</a><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link">常用框架</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs.advanced.way/docs/framework/spring/">常用框架</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/framework/mybatis/">Mybatis</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/framework/auth/">权限管理</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link">中间件</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs.advanced.way/docs/distributed/">分布式</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/tranctional/">事务</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/servicemesh/">服务网格</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/mq/">消息队列</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link">云原生</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs.advanced.way/docs/cloud/docker/base/镜像/">Docker容器</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/k8s/">K8s</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/serverless/">Serverless</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link">服务器</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs.advanced.way/docs/linux/">Linux</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/cache/">缓存</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/db/mysql/InnoDB/">数据库</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/cs/network/tcpip/">计算机系统</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link">编码实践</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs.advanced.way/docs/algorithm/algorithm/">算法/数据结构</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/patterns/">设计模式</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/architecture/">架构设计</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/job/java/">面试</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/memo/tool/系统初始化/">备忘</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link">小百科</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs.advanced.way/docs/cyclopedia/chinese/notes/dingding/">课堂笔记</a></li><li><a class="dropdown__link" href="/docs.advanced.way/docs/cyclopedia/chinese/lan/idiom/">大中国</a></li></ul></div></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/docs.advanced.way/blog">博客</a><a href="https://github.com/Goldwood1024/docs.advanced.way.git" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_GrZ2"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/docs.advanced.way/"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">进阶之路</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs.advanced.way/docs/java/">Java</a></li><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist">常用框架</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/framework/spring/">常用框架</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/framework/mybatis/">Mybatis</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/framework/auth/">权限管理</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist">中间件</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/distributed/">分布式</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/tranctional/">事务</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/servicemesh/">服务网格</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/mq/">消息队列</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist">云原生</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/cloud/docker/base/镜像/">Docker容器</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/k8s/">K8s</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/serverless/">Serverless</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist">服务器</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/linux/">Linux</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/cache/">缓存</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/db/mysql/InnoDB/">数据库</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/cs/network/tcpip/">计算机系统</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist">编码实践</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/algorithm/algorithm/">算法/数据结构</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/patterns/">设计模式</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/architecture/">架构设计</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/job/java/">面试</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/memo/tool/系统初始化/">备忘</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist">小百科</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/cyclopedia/chinese/notes/dingding/">课堂笔记</a></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/docs/cyclopedia/chinese/lan/idiom/">大中国</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/docs.advanced.way/blog">博客</a></li><li class="menu__list-item"><a href="https://github.com/Goldwood1024/docs.advanced.way.git" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper main-docs-wrapper"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo sidebarWithHideableNavbar_267A"><a tabindex="-1" class="sidebarLogo_3h0W" href="/docs.advanced.way/"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/docs.advanced.way/img/logo.svg" alt="进阶之路 Logo" class="themedImage_1VuW themedImage--dark_hz6m"><strong>进阶之路</strong></a><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">基础</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/">简介</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/base64">Base64编码</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/io">I/O</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/nio">NIO</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/object">面向对象</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/String">String</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/Reference">对象引用</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/代理">代理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/关键字">关键字</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/函数式接口">函数式接口</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/反射">反射</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/base/数据类型">数据类型</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">集合</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/collection/Collection">Collection</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/collection/List">List</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/collection/Map">Map</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">高并发</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/高并发">高并发</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/多线程">多线程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/并发编程的艺术">并发编程的艺术</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/内存模型">内存模型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/原子类">原子类</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/并发容器">并发容器</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/并发工具类">并发工具类</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs.advanced.way/docs/java/hc/线程池">线程池</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs.advanced.way/docs/java/hc/锁">锁</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">JVM</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/对象创建过程">对象创建过程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/对象回收机制">对象回收机制</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/jvm参数">JVM参数</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/jvm内存模型">内存模型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/内存优化">内存优化</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs.advanced.way/docs/java/jvm/垃圾收集器">垃圾收集器</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">锁</h1></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="java-中的锁"></a>java 中的锁<a class="hash-link" href="#java-中的锁" title="Direct link to heading">#</a></h2><p><img src="/docs.advanced.way/assets/images/640-413e947922353cd93599f13791e8d4e4.png"></p><table><thead><tr><th align="left">锁名称</th><th align="left">应用</th><th></th></tr></thead><tbody><tr><td align="left">1</td><td align="left">乐观锁</td><td>CAS</td></tr><tr><td align="left">2</td><td align="left">悲观锁</td><td>synchronized、vector、hashtable</td></tr><tr><td align="left">3</td><td align="left">自旋锁</td><td>CAS</td></tr><tr><td align="left">4</td><td align="left">可重入锁</td><td>synchronized、Reentrantlock、Lock</td></tr><tr><td align="left">5</td><td align="left">读写锁</td><td>ReentrantReadWriteLock，CopyOnWriteArrayList、CopyOnWriteArraySet</td></tr><tr><td align="left">6</td><td align="left">公平锁</td><td>Reentrantlock(true)</td></tr><tr><td align="left">7</td><td align="left">非公平锁</td><td>synchronized、reentrantlock(false)</td></tr><tr><td align="left">8</td><td align="left">共享锁</td><td>ReentrantReadWriteLock中读锁</td></tr><tr><td align="left">9</td><td align="left">独占锁</td><td>synchronized、vector、hashtable、ReentrantReadWriteLock中写锁</td></tr><tr><td align="left">10</td><td align="left">重量级锁</td><td>synchronized</td></tr><tr><td align="left">11</td><td align="left">轻量级锁</td><td>锁优化技术</td></tr><tr><td align="left">12</td><td align="left">偏向锁</td><td>锁优化技术</td></tr><tr><td align="left">13</td><td align="left">分段锁</td><td>concurrentHashMap</td></tr><tr><td align="left">14</td><td align="left">互斥锁</td><td>synchronized</td></tr><tr><td align="left">15</td><td align="left">同步锁</td><td>synchronized</td></tr><tr><td align="left">16</td><td align="left">死锁</td><td>相互请求对方的资源</td></tr><tr><td align="left">17</td><td align="left">锁粗化</td><td>锁优化技术</td></tr><tr><td align="left">18</td><td align="left">锁消除</td><td>锁优化技术</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="乐观锁"></a>乐观锁<a class="hash-link" href="#乐观锁" title="Direct link to heading">#</a></h3><p><strong>乐观锁是一种乐观思想</strong></p><p>假定当前环境是读多写少，遇到并发写的概率比较低，读数据时认为别的线程不会正在进行修改（所以没有上锁）。写数据时，判断当前 与期望值是否相同，如果相同则进行更新（更新期间加锁，保证是原子性的）</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="悲观锁"></a>悲观锁<a class="hash-link" href="#悲观锁" title="Direct link to heading">#</a></h3><p><strong>悲观锁是一种悲观思想</strong></p><p>认为写多读少，遇到并发写的可能性高，每次去拿数据的时候都认为其他线程会修改，所以每次读写数据都会认为其他线程会修改，所以每次读写数据时都会上锁。其他线程想要读写这个数据时，会被这个线程 block，直到这个线程释放锁然后其他线程获取到锁</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="自旋锁"></a>自旋锁<a class="hash-link" href="#自旋锁" title="Direct link to heading">#</a></h3><p>为了让线程等待，我们只须让线程执行一个忙循环（自旋）</p><p>自旋锁的优点：避免了线程切换的开销。挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给 Java 虚拟机的并发性能带来了很大的压力。</p><p>自旋锁的缺点：占用处理器的时间，如果占用的时间很长，会白白消耗处理器资源，而不会做任何有价值的工作，带来性能的浪费。因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。
自旋次数默认值：10次。可以使用参数 -XX:PreBlockSpin 来自行更改。</p><p>自适应自旋：自适应意味着自旋的时间不再是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善，虚拟机对程序锁的状态预测就会越来越精准。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="可重入锁（递归锁）"></a>可重入锁（递归锁）<a class="hash-link" href="#可重入锁（递归锁）" title="Direct link to heading">#</a></h3><p>任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞</p><ul><li>再次获取锁：识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。获取锁后，进行计数自增，</li><li>释放锁：释放锁时，进行计数自减</li></ul><p>面试题1：可重入锁如果加了两把，但是只释放了一把会出现什么问题？
答：程序卡死，线程不能出来，也就是说我们申请了几把锁，就需要释放几把锁。</p><p>面试题2：如果只加了一把锁，释放两次会出现什么问题？
答：会报错，抛出 java.lang.IllegalMonitorStateException。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="读写锁"></a>读写锁<a class="hash-link" href="#读写锁" title="Direct link to heading">#</a></h3><p>通过 ReentrantReadWriteLock 类来实现</p><p>为了提高性能， Java 提供了读写锁。在读的地方使用读锁，在写的地方使用写锁，灵活控制。如果没有写锁的情况下，读是无阻塞的。在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 JVM 自己控制的</p><ul><li>读锁：允许多个线程获取读锁，同时访问同一个资源</li><li>写锁：只允许一个线程获取写锁，不允许同时访问同一个资源</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="公平锁"></a>公平锁<a class="hash-link" href="#公平锁" title="Direct link to heading">#</a></h3><p><strong>公平锁是一种思想</strong></p><p>多个线程按照申请锁的顺序来获取锁</p><p>在并发环境中，每个线程会先查看此锁维护的等待队列，如果当前等待队列为空，则占有锁，如果等待队列不为空，则加入到等待队列的末尾，按照 FIFO 的原则从队列中拿到线程，然后占有锁</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="非公平锁"></a>非公平锁<a class="hash-link" href="#非公平锁" title="Direct link to heading">#</a></h3><p><strong>非公平锁是一种思想</strong></p><p>线程尝试获取锁，如果获取不到，则再采用公平锁的方式</p><p>多个线程获取锁的顺序，不是按照先到先得的顺序，有可能后申请锁的线程比先申请的线程优先获取锁</p><ul><li>优点：非公平锁的性能高于公平锁。</li><li>缺点：有可能造成线程饥饿（某个线程很长一段时间获取不到锁）</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="共享锁"></a>共享锁<a class="hash-link" href="#共享锁" title="Direct link to heading">#</a></h3><p><strong>共享锁是一种思想</strong></p><p>可以有多个线程获取读锁，以共享的方式持有锁。和乐观锁、读写锁同义</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="独占锁"></a>独占锁<a class="hash-link" href="#独占锁" title="Direct link to heading">#</a></h3><p><strong>独占锁是一种思想</strong></p><p>只能有一个线程获取锁，以独占的方式持有锁。和悲观锁、互斥锁同义</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="重量级锁"></a>重量级锁<a class="hash-link" href="#重量级锁" title="Direct link to heading">#</a></h3><p><img src="/docs.advanced.way/assets/images/6401-dda11f799beb99fd509470517c72d46f.png"></p><p>重量级锁是一种称谓：synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。监视器锁本身依赖底层的操作系统的 Mutex Lock 来实现。操作系统实现线程的切换需要从用户态切换到核心态，成本非常高。这种依赖于操作系统 Mutex Lock来实现的锁称为重量级锁。为了优化 synchonized 引入了轻量级锁，偏向锁</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="轻量级锁"></a>轻量级锁<a class="hash-link" href="#轻量级锁" title="Direct link to heading">#</a></h3><p><img src="/docs.advanced.way/assets/images/640223-dda11f799beb99fd509470517c72d46f.png"></p><p>轻量级锁是 JDK6 时加入的一种锁优化机制：轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量。轻量级是相对于使用操作系统互斥量来实现的重量级锁而言的。轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁将不会有效，必须膨胀为重量级锁。</p><p>优点：如果没有竞争，通过 CAS 操作成功避免了使用互斥量的开销。
缺点：如果存在竞争，除了互斥量本身的开销外，还额外产生了 CAS 操作的开销，因此在有竞争的情况下，轻量级锁比传统的重量级锁更慢</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="偏向锁"></a>偏向锁<a class="hash-link" href="#偏向锁" title="Direct link to heading">#</a></h3><p><img src="/docs.advanced.way/assets/images/640112-4d5bf6922e9abfa0a6deb650d7a95d1f.png"></p><p>偏向锁是 JDK6 时加入的一种锁优化机制：在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不去做了。偏是指偏心，它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对 Mark Word 的更新操作等）。</p><p>优点：把整个同步都消除掉，连 CAS 操作都不去做了，优于轻量级锁。
缺点：如果程序中大多数的锁都总是被多个不同的线程访问，那偏向锁就是多余的</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="分段锁"></a>分段锁<a class="hash-link" href="#分段锁" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="互斥锁"></a>互斥锁<a class="hash-link" href="#互斥锁" title="Direct link to heading">#</a></h3><p>互斥锁与悲观锁、独占锁同义，表示某个资源只能被一个线程访问，其他线程不能访问。</p><p>读读互斥；
读写互斥；
写读互斥；
写写互斥。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="同步锁"></a>同步锁<a class="hash-link" href="#同步锁" title="Direct link to heading">#</a></h3><p>同步锁与互斥锁同义，表示并发执行的多个线程，在同一时间内只允许一个线程访问共享数据</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="死锁"></a>死锁<a class="hash-link" href="#死锁" title="Direct link to heading">#</a></h3><p>死锁是一种现象：如线程 A 持有资源 x，线程 B 持有资源 y，线程 A 等待线程 B 释放资源 y，线程 B 等待线程 A 释放资源 x，两个线程都不释放自己持有的资源，则两个线程都获取不到对方的资源，就会造成死锁。</p><p>Java 中的死锁不能自行打破。所以线程死锁后，线程不能进行响应。所以一定要注意程序的并发场景，避免造成死锁</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="锁粗化"></a>锁粗化<a class="hash-link" href="#锁粗化" title="Direct link to heading">#</a></h3><p>锁粗化是一种优化技术：如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作都是出现在循环体体之中，就算真的没有线程竞争，频繁地进行互斥同步操作将会导致不必要的性能损耗。所以就采取了一种方案：把加锁的范围扩展（粗化）到整个操作序列的外部，这样加锁解锁的频率就会大大降低，从而减少了性能损耗</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="锁消除"></a>锁消除<a class="hash-link" href="#锁消除" title="Direct link to heading">#</a></h3><p>锁消除是一种优化技术：就是把锁干掉。当 Java  虚拟机运行时发现有些共享数据不会被线程竞争时就可以进行锁消除。</p><p>那如何判断共享数据不会被线程竞争？</p><p>利用逃逸分析技术：分析对象的作用域，如果对象在 A 方法中定义后，被作为参数传递到B方法中，则称为方法逃逸；如果被其他线程访问，则称为线程逃逸。</p><p>在堆上的某个数据不会逃逸出去被其他线程访问到，就可以把它当作栈上数据对待，认为它是线程私有的，同步加锁就不需要了</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="synchronized"></a>synchronized<a class="hash-link" href="#synchronized" title="Direct link to heading">#</a></h3><p><img src="/docs.advanced.way/assets/images/64044-f8c327aba078d43ab8bdf4aecfdcc002.png"></p><p>synchronized 是 Java中的关键字：用来修饰方法、对象实例。属于独占锁、悲观锁、可重入锁、非公平锁。</p><ul><li>作用于实例方法时，锁住的是对象的实例（this）；</li><li>当作用于静态方法时，锁住的是类（class）。相当于类的一个全局锁， 会锁所有调用该方法的线程；</li><li>synchronized 作用于一个非 null 的对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。</li></ul><p>每个对象都有个 monitor 对象， 加锁就是在竞争 monitor 对象。代码块加锁是在代码块前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="lock-和-synchronized-的区别"></a>Lock 和 synchronized 的区别<a class="hash-link" href="#lock-和-synchronized-的区别" title="Direct link to heading">#</a></h3><p>Lock 是 Java 中的接口，可重入锁、悲观锁、独占锁、互斥锁、同步锁。</p><ul><li>Lock 需要手动获取锁和释放锁。就好比自动挡和手动挡的区别；</li><li>Lock 是一个接口，而 synchronized 是 Java 中的关键字。synchronized 是 Java 语言内置的实现；</li><li><ul><li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock() 去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁；
Lock 可以让等待锁的线程响应中断，而 synchronized 却不行。使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断；</li></ul></li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到；</li><li>Lock 可以通过实现读写锁提高多个线程进行读操作的效率。</li></ul><p>synchronized 的优势：</p><ul><li>足够清晰简单，只需要基础的同步功能时，用 synchronized；</li><li>Lock 应该确保在 finally 块中释放锁。如果使用 synchronized，JVM确保即使出现异常，锁也能被自动释放；</li><li>使用 Lock 时，Java 虚拟机很难得知哪些锁对象是由特定线程锁持有的</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="reentrantlock-和-synchronized-的区别"></a>ReentrantLock 和 synchronized 的区别<a class="hash-link" href="#reentrantlock-和-synchronized-的区别" title="Direct link to heading">#</a></h3><p><img src="/docs.advanced.way/assets/images/64022-9d3118074c338c16a468d6705eb52a83.png"></p><p>ReentrantLock 是 Java 中的类：继承了 Lock 类，可重入锁、悲观锁、独占锁、互斥锁、同步锁。</p><p>相同点：</p><ul><li>主要解决共享变量如何安全访问的问题；</li><li>都是可重入锁，也叫做递归锁，同一线程可以多次获得同一个锁；</li><li>保证了线程安全的两大特性：可见性、原子性。</li></ul><p>不同点：</p><ul><li>ReentrantLock 就像手动汽车，需要显示的调用 lock 和 unlock 方法， synchronized 隐式获得释放锁；</li><li>ReentrantLock 可响应中断， synchronized 是不可以响应中断的，ReentrantLock 为处理锁的不可用性提供了更高的灵活性；</li><li>ReentrantLock 是 API 级别的， synchronized 是 JVM 级别的；</li><li>ReentrantLock 可以实现公平锁、非公平锁，默认非公平锁。synchronized 是非公平锁，且不可更改；</li><li>ReentrantLock 通过 Condition 可以绑定多个条件。</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="lock"></a>Lock<a class="hash-link" href="#lock" title="Direct link to heading">#</a></h2><p><img src="/docs.advanced.way/assets/images/885859-20190428143036791-1293316018-e5a7b2f769fe5e28a534d5c2cb59b91f.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="源码"></a>源码<a class="hash-link" href="#源码" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public interface Lock {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 获取锁</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    void lock();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 如果当前线程未被中断，则获取锁，可以响应中断 </span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    void lockInterruptibly() throws InterruptedException;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 仅在调用时锁为空闲状态才获取该锁，可以响应中断</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    boolean tryLock();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    </span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 返回绑定到此 Lock 实例的新 Condition 实例 </span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    Condition newCondition();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 释放锁</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    void unlock();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>lock()</li></ul><p>获取锁,如果锁已被其他线程获取，则进行等待</p><ul><li>lockInterruptibly()</li></ul><p>当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="队列同步器"></a>队列同步器<a class="hash-link" href="#队列同步器" title="Direct link to heading">#</a></h2><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public abstract class AbstractQueuedSynchronizer</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    extends AbstractOwnableSynchronizer</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    implements java.io.Serializable {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 队列</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    private transient volatile Node head;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    private transient volatile Node tail;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 同步队列用来保存获取同步状态失败的线程引用，等待状态、前驱节点、后驱节点、节点的属性等信息</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    static final class Node {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    /// 模式</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        // 共享</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        static final Node SHARED = new Node();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        // 独占</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        static final Node EXCLUSIVE = null;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    /// 状态</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        /** waitStatus value to indicate thread has cancelled. */</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        static final int CANCELLED =  1;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        /** waitStatus value to indicate successor&#x27;s thread needs unparking. */</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        static final int SIGNAL    = -1;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        /** waitStatus value to indicate thread is waiting on condition. */</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        static final int CONDITION = -2;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        /**</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * waitStatus value to indicate the next acquireShared should</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * unconditionally propagate.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         */</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        static final int PROPAGATE = -3;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        // 等待状态</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        volatile int waitStatus;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        volatile Node prev;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        volatile Thread thread;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        // 等待队列的后继节点</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        Node nextWaiter;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        // 获取同步状态的线程</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        volatile Thread thread;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        Node() {}</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        Node(Node nextWaiter) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            this.nextWaiter = nextWaiter;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            THREAD.set(this, Thread.currentThread());</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 同步状态</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    private volatile int state;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 获取当前同步状态</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    protected final int getState() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        return state;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 设置当前同步状态</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    protected final void setState(int newState) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        state = newState;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 使用CAS设置当前同步状态</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    protected final boolean compareAndSetState(int expect, int update) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        return STATE.compareAndSet(this, expect, update);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">///// 独占式同步状态获取和释放</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 获取同步</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public final void acquire(int arg) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        /*</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            1. tryAcquire 线程安全的获取同步状态</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            2. 获取失败，构造同步节点（独占式 Node.EXCLUSIVE） 并通过addWaiter(Node node)把节点放入队尾</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            3. 调用 acquireQueued 获取同步状态</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        */</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        if (!tryAcquire(arg) &amp;&amp;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            selfInterrupt();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 子类需要重写</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    protected boolean tryAcquire(int arg) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        throw new UnsupportedOperationException();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    private Node addWaiter(Node mode) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        // 创建节点</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        Node node = new Node(mode);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        // 放入队列尾部</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        for (;;) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            Node oldTail = tail;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            if (oldTail != null) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                node.setPrevRelaxed(oldTail);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                if (compareAndSetTail(oldTail, node)) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    oldTail.next = node;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    return node;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            } else {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                initializeSyncQueue();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    final boolean acquireQueued(final Node node, int arg) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        boolean interrupted = false;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        try {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            for (;;) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                final Node p = node.predecessor();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                if (p == head &amp;&amp; tryAcquire(arg)) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    setHead(node);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    p.next = null; // help GC</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    return interrupted;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                if (shouldParkAfterFailedAcquire(p, node))</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    interrupted |= parkAndCheckInterrupt();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        } catch (Throwable t) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            cancelAcquire(node);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            if (interrupted)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                selfInterrupt();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            throw t;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 释放</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public final boolean release(int arg) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        // 释放同步状态</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        if (tryRelease(arg)) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            Node h = head;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            if (h != null &amp;&amp; h.waitStatus != 0)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                // 唤醒头结点的后继节点</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                unparkSuccessor(h);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            return true;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        return false;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 子类需要重写</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    protected boolean tryRelease(int arg) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        throw new UnsupportedOperationException();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    private void unparkSuccessor(Node node) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        /*</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * If status is negative (i.e., possibly needing signal) try</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * to clear in anticipation of signalling.  It is OK if this</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * fails or if status is changed by waiting thread.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         */</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        int ws = node.waitStatus;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        if (ws &lt; 0)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            node.compareAndSetWaitStatus(ws, 0);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        /*</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * Thread to unpark is held in successor, which is normally</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * just the next node.  But if cancelled or apparently null,</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * traverse backwards from tail to find the actual</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * non-cancelled successor.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         */</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        Node s = node.next;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        if (s == null || s.waitStatus &gt; 0) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            s = null;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            for (Node p = tail; p != node &amp;&amp; p != null; p = p.prev)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                if (p.waitStatus &lt;= 0)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    s = p;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        if (s != null)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            LockSupport.unpark(s.thread);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">///// 共享式</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public final void acquireShared(int arg) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        if (tryAcquireShared(arg) &lt; 0)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            doAcquireShared(arg);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    protected int tryAcquireShared(int arg) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        throw new UnsupportedOperationException();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    private void doAcquireShared(int arg) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        final Node node = addWaiter(Node.SHARED);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        boolean interrupted = false;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        try {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            for (;;) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                final Node p = node.predecessor();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                // 如果当前节点的前驱节点为头结点，尝试获取同步状态</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                if (p == head) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    int r = tryAcquireShared(arg);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    if (r &gt;= 0) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                        setHeadAndPropagate(node, r);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                        p.next = null; // help GC</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                        return;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                if (shouldParkAfterFailedAcquire(p, node))</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    interrupted |= parkAndCheckInterrupt();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        } catch (Throwable t) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            cancelAcquire(node);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            throw t;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        } finally {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            if (interrupted)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                selfInterrupt();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public final boolean releaseShared(int arg) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        if (tryReleaseShared(arg)) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            doReleaseShared();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            return true;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        return false;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    protected boolean tryReleaseShared(int arg) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        throw new UnsupportedOperationException();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    private void doReleaseShared() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        /*</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * Ensure that a release propagates, even if there are other</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * in-progress acquires/releases.  This proceeds in the usual</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * way of trying to unparkSuccessor of head if it needs</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * signal. But if it does not, status is set to PROPAGATE to</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * ensure that upon release, propagation continues.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * Additionally, we must loop in case a new node is added</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * while we are doing this. Also, unlike other uses of</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * unparkSuccessor, we need to know if CAS to reset status</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * fails, if so rechecking.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         */</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        for (;;) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            Node h = head;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            if (h != null &amp;&amp; h != tail) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                int ws = h.waitStatus;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                if (ws == Node.SIGNAL) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    if (!h.compareAndSetWaitStatus(Node.SIGNAL, 0))</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                        continue;            // loop to recheck cases</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    unparkSuccessor(h);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                else if (ws == 0 &amp;&amp;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                         !h.compareAndSetWaitStatus(0, Node.PROPAGATE))</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    continue;                // loop on failed CAS</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            if (h == head)                   // loop if head changed</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                break;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="重入锁-reentrantlock"></a>重入锁 ReentrantLock<a class="hash-link" href="#重入锁-reentrantlock" title="Direct link to heading">#</a></h2><p>支持重进入的锁，支持一个线程对资源重复加锁</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="结构图"></a>结构图<a class="hash-link" href="#结构图" title="Direct link to heading">#</a></h3><p><img src="/docs.advanced.way/assets/images/ReentrantLock-f5b2df8490b15a5b1297d7dd01650a3b.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="源码-1"></a>源码<a class="hash-link" href="#源码-1" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class ReentrantLock implements Lock, java.io.Serializable {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    private final Sync sync;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    abstract static class Sync extends AbstractQueuedSynchronizer {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        private static final long serialVersionUID = -5179523762034025860L;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        /**</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * Performs non-fair tryLock.  tryAcquire is implemented in</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * subclasses, but both need nonfair try for trylock method.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         */</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        @ReservedStackAccess</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        final boolean nonfairTryAcquire(int acquires) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            final Thread current = Thread.currentThread();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            int c = getState();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            if (c == 0) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                if (compareAndSetState(0, acquires)) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    setExclusiveOwnerThread(current);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    return true;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            else if (current == getExclusiveOwnerThread()) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                // 同步状态增加</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                int nextc = c + acquires;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                if (nextc &lt; 0) // overflow</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                setState(nextc);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                return true;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            return false;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        @ReservedStackAccess</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        protected final boolean tryRelease(int releases) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            // 释放减少同步状态值</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            int c = getState() - releases;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            if (Thread.currentThread() != getExclusiveOwnerThread())</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                throw new IllegalMonitorStateException();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            boolean free = false;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            // c为0 说明没有线程持有锁则释放锁</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            if (c == 0) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                free = true;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                setExclusiveOwnerThread(null);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            setState(c);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            return free;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        protected final boolean isHeldExclusively() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            // While we must in general read state before owner,</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            // we don&#x27;t need to do so to check if current thread is owner</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            return getExclusiveOwnerThread() == Thread.currentThread();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        final ConditionObject newCondition() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            return new ConditionObject();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        // Methods relayed from outer class</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        final Thread getOwner() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            return getState() == 0 ? null : getExclusiveOwnerThread();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        final int getHoldCount() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            return isHeldExclusively() ? getState() : 0;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        final boolean isLocked() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            return getState() != 0;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        /**</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         * Reconstitutes the instance from a stream (that is, deserializes it).</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         */</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        private void readObject(java.io.ObjectInputStream s)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            throws java.io.IOException, ClassNotFoundException {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            s.defaultReadObject();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            setState(0); // reset to unlocked state</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 非公平锁</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    static final class NonfairSync extends Sync {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        private static final long serialVersionUID = 7316153563782823691L;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        protected final boolean tryAcquire(int acquires) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            return nonfairTryAcquire(acquires);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 公平锁</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    static final class FairSync extends Sync {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        private static final long serialVersionUID = -3000897897090466540L;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        </span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        @ReservedStackAccess</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        protected final boolean tryAcquire(int acquires) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            final Thread current = Thread.currentThread();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            int c = getState();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            if (c == 0) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                if (!hasQueuedPredecessors() &amp;&amp;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    compareAndSetState(0, acquires)) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    setExclusiveOwnerThread(current);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    return true;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            // 判断当前线程是否为获取锁的线程来决定获取操作是否成功，获取锁的线程再次请求，将同步状态增加</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            else if (current == getExclusiveOwnerThread()) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                int nextc = c + acquires;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                if (nextc &lt; 0)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                setState(nextc);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                return true;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            return false;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 创建锁 默认为非公平锁</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public ReentrantLock() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        sync = new NonfairSync();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 指定模式</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public ReentrantLock(boolean fair) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        sync = fair ? new FairSync() : new NonfairSync();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 获取锁</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public void lock() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        sync.acquire(1);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 释放锁</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public void unlock() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        sync.release(1);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public Condition newCondition() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        return sync.newCondition();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public boolean tryLock() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        return sync.nonfairTryAcquire(1);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="公平锁和非公平锁"></a>公平锁和非公平锁<a class="hash-link" href="#公平锁和非公平锁" title="Direct link to heading">#</a></h3><p>公平锁: 获取锁定顺序和请求的时间顺序相同
独占式: 同一个时间只能有一个线程获取锁</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="读写锁-1"></a>读写锁<a class="hash-link" href="#读写锁-1" title="Direct link to heading">#</a></h2><p>同一时刻允许多个线程获取锁</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="特性"></a>特性<a class="hash-link" href="#特性" title="Direct link to heading">#</a></h3><ul><li>支持公平性选择</li><li>支持可重入</li><li>锁降级 写锁可以降级为读锁</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="结构图-1"></a>结构图<a class="hash-link" href="#结构图-1" title="Direct link to heading">#</a></h3><p><img src="/docs.advanced.way/assets/images/ReentrantReadWriteLock-522f52a6ef6d10b2644e61bde88255c7.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="原理"></a>原理<a class="hash-link" href="#原理" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="readwritelockjava"></a>ReadWriteLock.java<a class="hash-link" href="#readwritelockjava" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public interface ReadWriteLock {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    Lock readLock();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    Lock writeLock();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="reentrantreadwritelockjava"></a>ReentrantReadWriteLock.java<a class="hash-link" href="#reentrantreadwritelockjava" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class ReentrantReadWriteLock</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        implements ReadWriteLock, java.io.Serializable {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    private final ReentrantReadWriteLock.ReadLock readerLock;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    private final ReentrantReadWriteLock.WriteLock writerLock;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    final Sync sync;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    abstract static class Sync extends AbstractQueuedSynchronizer {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 构造默认的读写锁</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public ReentrantReadWriteLock() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        this(false);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public ReentrantReadWriteLock(boolean fair) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        sync = fair ? new FairSync() : new NonfairSync();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        // 创建读锁</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        readerLock = new ReadLock(this);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        // 创建写锁</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        writerLock = new WriteLock(this);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public static class ReadLock implements Lock, java.io.Serializable {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        private final Sync sync;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        protected ReadLock(ReentrantReadWriteLock lock) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            sync = lock.sync;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        public void lock() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            // 共享锁</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            sync.acquireShared(1);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        public void unlock() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            sync.releaseShared(1);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public static class WriteLock implements Lock, java.io.Serializable {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        private final Sync sync;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        protected WriteLock(ReentrantReadWriteLock lock) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            sync = lock.sync;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        public void lock() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            // AQS</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            sync.acquire(1);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        public void unlock() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            // AQS</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            sync.release(1);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        // 持有数量</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        public int getHoldCount() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            return sync.getWriteHoldCount();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    static final class NonfairSync extends Sync {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        private static final long serialVersionUID = -8159625535654395037L;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        final boolean writerShouldBlock() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            return false; // writers can always barge</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        final boolean readerShouldBlock() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            /* As a heuristic to avoid indefinite writer starvation,</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">             * block if the thread that momentarily appears to be head</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">             * of queue, if one exists, is a waiting writer.  This is</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">             * only a probabilistic effect since a new reader will not</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">             * block if there is a waiting writer behind other enabled</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">             * readers that have not yet drained from the queue.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">             */</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            return apparentlyFirstQueuedIsExclusive();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 公平锁</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    static final class FairSync extends Sync {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        private static final long serialVersionUID = -2274990926593161451L;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        final boolean writerShouldBlock() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            return hasQueuedPredecessors();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        final boolean readerShouldBlock() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            return hasQueuedPredecessors();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p><code>按位切割使用</code> 变量 <code>state</code>, 读写锁将变量分为两个部分。高16位表示读，低16位表示写。</p><p>位运算
假设当前同步状态为S ,写状态为 S &amp; 0x0000FFFF; 读状态为 S &gt;&gt; 16</p><p>写状态加1，等于S+1; 读状态加1, 等于 S+(1&lt;&lt;16)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="locksupport"></a>LockSupport<a class="hash-link" href="#locksupport" title="Direct link to heading">#</a></h2><p>提供了基本线程阻塞和唤醒的方法</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class LockSupport {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 不可以被实例化</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    private LockSupport() {}</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 获取 Unsafe 实例</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    private static final Unsafe U = Unsafe.getUnsafe();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 阻塞线程</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public static void park() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        U.park(false, 0L);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 唤醒线程</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public static void unpark(Thread thread) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        if (thread != null)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            U.unpark(thread);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="condition"></a>Condition<a class="hash-link" href="#condition" title="Direct link to heading">#</a></h2><p>于 Lock 配合实现等待/通知模式</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public interface Condition {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 当前线程进入等待状态直到被通知或中断</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    void await() throws InterruptedException;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 当前线程进入等待状态直到被通知</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    void awaitUninterruptibly();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 当前线程进入等待状态直到被通知、中断、超时。返回值标识剩余的时间</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    long awaitNanos(long nanosTimeout) throws InterruptedException;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 唤醒一个等待在Condition 的线程</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    void signal();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 唤醒所有等待在Condition 的线程</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    void signalAll();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">// 作为AQS的内部类实现</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public abstract class AbstractQueuedSynchronizer</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    extends AbstractOwnableSynchronizer</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    implements java.io.Serializable {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public class ConditionObject implements Condition, java.io.Serializable {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        </span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        // 等待队列</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        private transient Node firstWaiter;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        private transient Node lastWaiter;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        public ConditionObject() { }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        // 阻塞线程</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        public final void await() throws InterruptedException {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            // 已中断 抛出异常</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            if (Thread.interrupted())</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                throw new InterruptedException();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            // 当前线程加入等待队列</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            Node node = addConditionWaiter();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            // 释放同步状态，即释放锁</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            int savedState = fullyRelease(node);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            int interruptMode = 0;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            while (!isOnSyncQueue(node)) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                LockSupport.park(this);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    break;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                interruptMode = REINTERRUPT;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            if (node.nextWaiter != null) // clean up if cancelled</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                unlinkCancelledWaiters();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            if (interruptMode != 0)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                reportInterruptAfterWait(interruptMode);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        // 增加一个新的Waiter到等待队列</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        private Node addConditionWaiter() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            if (!isHeldExclusively())</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                throw new IllegalMonitorStateException();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            Node t = lastWaiter;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            // If lastWaiter is cancelled, clean out.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                unlinkCancelledWaiters();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                t = lastWaiter;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            Node node = new Node(Node.CONDITION);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            if (t == null)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                firstWaiter = node;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            else</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                t.nextWaiter = node;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            lastWaiter = node;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            return node;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        // 唤醒线程（等待队列的首节点）</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        public final void signal() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            // 检查是否获取了锁</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            if (!isHeldExclusively())</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                throw new IllegalMonitorStateException();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            Node first = firstWaiter;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            if (first != null)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                doSignal(first);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        private void doSignal(Node first) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            do {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                if ( (firstWaiter = first.nextWaiter) == null)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                    lastWaiter = null;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                first.nextWaiter = null;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                // 将 等待队列的头结点线程安全的移动到同步队列</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            } while (!transferForSignal(first) &amp;&amp;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                     (first = firstWaiter) != null);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>线程进入等待状态释放锁，唤醒前需要先获取到锁</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="参考"></a>参考<a class="hash-link" href="#参考" title="Direct link to heading">#</a></h2><p><a href="https://mp.weixin.qq.com/s/kMyyHaDQn-Da8MTmpPUyfg" target="_blank" rel="noopener noreferrer">24张图带你彻底理解Java中的21种锁</a></p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Goldwood1024/docs.advanced.way/docs/docs/java/hc/锁.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-03-19T05:21:18.000Z" class="lastUpdatedDate_1WI_">3/19/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs.advanced.way/docs/java/hc/线程池"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 线程池</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs.advanced.way/docs/java/jvm/对象创建过程"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">对象创建过程 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#java-中的锁" class="table-of-contents__link">java 中的锁</a><ul><li><a href="#乐观锁" class="table-of-contents__link">乐观锁</a></li><li><a href="#悲观锁" class="table-of-contents__link">悲观锁</a></li><li><a href="#自旋锁" class="table-of-contents__link">自旋锁</a></li><li><a href="#可重入锁（递归锁）" class="table-of-contents__link">可重入锁（递归锁）</a></li><li><a href="#读写锁" class="table-of-contents__link">读写锁</a></li><li><a href="#公平锁" class="table-of-contents__link">公平锁</a></li><li><a href="#非公平锁" class="table-of-contents__link">非公平锁</a></li><li><a href="#共享锁" class="table-of-contents__link">共享锁</a></li><li><a href="#独占锁" class="table-of-contents__link">独占锁</a></li><li><a href="#重量级锁" class="table-of-contents__link">重量级锁</a></li><li><a href="#轻量级锁" class="table-of-contents__link">轻量级锁</a></li><li><a href="#偏向锁" class="table-of-contents__link">偏向锁</a></li><li><a href="#分段锁" class="table-of-contents__link">分段锁</a></li><li><a href="#互斥锁" class="table-of-contents__link">互斥锁</a></li><li><a href="#同步锁" class="table-of-contents__link">同步锁</a></li><li><a href="#死锁" class="table-of-contents__link">死锁</a></li><li><a href="#锁粗化" class="table-of-contents__link">锁粗化</a></li><li><a href="#锁消除" class="table-of-contents__link">锁消除</a></li><li><a href="#synchronized" class="table-of-contents__link">synchronized</a></li><li><a href="#lock-和-synchronized-的区别" class="table-of-contents__link">Lock 和 synchronized 的区别</a></li><li><a href="#reentrantlock-和-synchronized-的区别" class="table-of-contents__link">ReentrantLock 和 synchronized 的区别</a></li></ul></li><li><a href="#lock" class="table-of-contents__link">Lock</a><ul><li><a href="#源码" class="table-of-contents__link">源码</a></li></ul></li><li><a href="#队列同步器" class="table-of-contents__link">队列同步器</a></li><li><a href="#重入锁-reentrantlock" class="table-of-contents__link">重入锁 ReentrantLock</a><ul><li><a href="#结构图" class="table-of-contents__link">结构图</a></li><li><a href="#源码-1" class="table-of-contents__link">源码</a></li><li><a href="#公平锁和非公平锁" class="table-of-contents__link">公平锁和非公平锁</a></li></ul></li><li><a href="#读写锁-1" class="table-of-contents__link">读写锁</a><ul><li><a href="#特性" class="table-of-contents__link">特性</a></li><li><a href="#结构图-1" class="table-of-contents__link">结构图</a></li><li><a href="#原理" class="table-of-contents__link">原理</a></li></ul></li><li><a href="#locksupport" class="table-of-contents__link">LockSupport</a></li><li><a href="#condition" class="table-of-contents__link">Condition</a></li><li><a href="#参考" class="table-of-contents__link">参考</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 进阶之路, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/docs.advanced.way/assets/js/styles.ddded6a8.js"></script>
<script src="/docs.advanced.way/assets/js/runtime~main.5d198aef.js"></script>
<script src="/docs.advanced.way/assets/js/main.131ff777.js"></script>
<script src="/docs.advanced.way/assets/js/1.6e33c73b.js"></script>
<script src="/docs.advanced.way/assets/js/2.88860bc9.js"></script>
<script src="/docs.advanced.way/assets/js/3.52177707.js"></script>
<script src="/docs.advanced.way/assets/js/1be78505.9a733b12.js"></script>
<script src="/docs.advanced.way/assets/js/198.598f71db.js"></script>
<script src="/docs.advanced.way/assets/js/935f2afb.dbe87953.js"></script>
<script src="/docs.advanced.way/assets/js/17896441.71928309.js"></script>
<script src="/docs.advanced.way/assets/js/40065f64.c8983bd3.js"></script>
</body>
</html>